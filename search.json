[{"title":"java面向对象编程","url":"/2022/07/15/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"java笔记\n\n\n基础内容基本数据类型byte：\n\n最大值：127（2^7-1）\n\n最小值：128（-2^7）\n\n默认值：0\n\n例子：byte a &#x3D; 100;\n\n\nshort：\n\n最大值：32767（2^15 - 1）\n最小值：- 32768（-2^15）\n默认值：0\n例子：short r &#x3D; 2000\n\nint：\n\n最大值是 2,147,483,647（2^31 - 1）\n最小值是 -2,147,483,648（-2^31）\n默认值是 0 ；\n例子：int a &#x3D; 100000\n\nlong：\n\n最大值：9,223,372,036,854,775,807（2^63 -1）\n最小值：-9,223,372,036,854,775,808（-2^63）\n默认值：0L（L是不分大小写的，但是写成大写不容易看错）\n例子：long a &#x3D; 10L\n\nfloat：\n\n单精度32位浮点数\n例子：float num &#x3D; 233.45f\n\ndouble：\n\n双精度64位浮点数\n例子：double num &#x3D; 7\n\nboolean：\n\n布尔类型，用来表示真假\n取值：true和false\n例子：boolean flag &#x3D; true\n\nchar：\n\n字符类型\nchar a &#x3D; ‘A’\njava中字符串不是字符数组，它是引用类型\n\n控制语句输入输出输出\n使用System.out.println()来输出\nprintln是print line缩写 -&gt; 输出并换行\npublic class Main &#123;    public static void main(String[] args) &#123;        System.out.print(&quot;A,&quot;);        System.out.print(&quot;B,&quot;);        System.out.print(&quot;C.&quot;);        System.out.println();        System.out.println(&quot;END&quot;);    &#125;&#125;\n\n格式化输出\n格式化方式与C可以说是一样\npublic class Main &#123;    public static void main(String[] args) &#123;        double d = 3.1415926;        System.out.printf(&quot;%.2f\\n&quot;, d); // 显示两位小数3.14        System.out.printf(&quot;%.4f\\n&quot;, d); // 显示4位小数3.1416    &#125;&#125;\n\n输入\n输入比输出麻烦一些，需要导包使用Scanner类\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入你的名字&quot;);        String name = scanner.nextLine();        System.out.println(&quot;输入你的年龄&quot;);        int age = scanner.nextInt();        System.out.println(&quot;你的名字是：&quot;+name+&quot;\\n你的年龄是：&quot;+age);    &#125;&#125;\n\n流程控制for each循环\nfor each循环的变量n不再是计数器，而是直接对应到数组的每个元素。\npublic class Main &#123;    public static void main(String[] args) &#123;        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;        for (int n : ns) &#123;            System.out.println(n);        &#125;    &#125;&#125;\n\n数组操作java里面的多维数组可以每个数组里面的元素个数不相同\nint[][] ns = &#123;    &#123; 1, 2, 3, 4 &#125;,    &#123; 5, 6 &#125;,    &#123; 7, 8, 9 &#125;&#125;;\n\n打印二维数组\nfor (int[] arr : ns) &#123;    for (int n : arr) &#123;        System.out.print(n);        System.out.print(&#x27;, &#x27;);    &#125;    System.out.println();&#125;\n\n使用Arrays.deepToString()打印数组\n// 需要导包import java.util.Arrays;System.out.println(Arrays.deepToString(ns));/** 输出结果* [[1, 2, 3, 4], [5, 6], [7, 8, 9]]*/\n\n三维数组的定义\nint[][][] ns = &#123;    &#123;        &#123;1, 2, 3&#125;,        &#123;4, 5, 6&#125;,        &#123;7, 8, 9&#125;    &#125;,    &#123;        &#123;10, 11&#125;,        &#123;12, 13&#125;    &#125;,    &#123;        &#123;14, 15, 16&#125;,        &#123;17, 18&#125;    &#125;&#125;;\n\n面向对象编程","categories":["笔记","java"],"tags":["OOP","java"]},{"title":"PTA-C语言","url":"/2022/07/16/PTA-C%E8%AF%AD%E8%A8%80/","content":"前六个题目集，难度不是特别大。\n这篇文章左边的目录出毛病了，将就看。\n\n\n题目集1戍边英雄去年六月\n远在我国西北边陲广袤的大地上\n五位戍边英雄挺身而出\n用伟岸的身躯守护着\n中华大地上的每一寸“肌肤”\n\n他们分别是陈红军、王焯冉、祁发宝、肖思远、陈祥榕\n让我们用编程的形式向这些英雄致敬！\n输入样例:无\n\n输出样例:************************ Zhi Jing Ying Xiong **     Chen Hongjun    **     Wang Zhuoran    **       Qi Fabao      **     Xiao Siyuan     **     Chen Xiangrong  ************************\n\n题解分析代码#include&lt;stdio.h&gt;int main ()&#123;\tprintf(&quot;***********************\\n&quot;);\tprintf(&quot;* Zhi Jing Ying Xiong *\\n&quot;);\tprintf(&quot;*     Chen Hongjun    *\\n&quot;);\tprintf(&quot;*     Wang Zhuoran    *\\n&quot;);\tprintf(&quot;*       Qi Fabao      *\\n&quot;);\tprintf(&quot;*     Xiao Siyuan     *\\n&quot;);\tprintf(&quot;*     Chen Xiangrong  *\\n&quot;);\tprintf(&quot;***********************&quot;);\treturn 0; &#125;\n\nWelcome to You!本题要求编写程序，输出一个短句“Welcome to You!”。\n输入格式:本题目没有输入。\n输出格式:在一行中输出短句“Welcome to You!”。\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Welcome to You!&quot;);\treturn 0;&#125;\n\n输出倒三角图案本题要求编写程序，输出指定的由“*”组成的倒三角图案。\n输入格式:本题目没有输入。\n输出格式:按照下列格式输出由“*”组成的倒三角图案。\n* * * * * * *  * *   *\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;* * * *\\n&quot;);\tprintf(&quot; * * *\\n&quot;);\tprintf(&quot;  * *\\n&quot;);\tprintf(&quot;   *\\n&quot;);\t\treturn 0; &#125;\n\n打印菜单本题要求编写程序，在屏幕上打印5行菜单。\n输入格式:本题目没有输入。\n输出格式:按照下列格式打印菜单，每行显示一句。注意除了每行的换行不能有任何多余字符。\n[1] Select crisps\n[2] Select popcorn\n[3] Select chocolate\n[4] Select cola\n[0] Exit\n输入样例:输出样例:[1] Select crisps[2] Select popcorn[3] Select chocolate[4] Select cola[0] Exit\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;[1] Select crisps\\n&quot;);\tprintf(&quot;[2] Select popcorn\\n&quot;);\tprintf(&quot;[3] Select chocolate\\n&quot;);\tprintf(&quot;[4] Select cola\\n&quot;);\tprintf(&quot;[0] Exit\\n&quot;);\treturn 0;&#125;\n\n混合类型数据格式化输入本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。\n输入格式：输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。\n输出格式：在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。\n输入样例：2.12 88 c 4.7\n\n输出样例：c 88 2.12 4.70\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint a;\tchar b;\tfloat c, d;\tscanf(&quot;%f %d %c %f&quot;, &amp;c, &amp;a, &amp;b, &amp;d);\tprintf(&quot;%c %d %.2f %.2f\\n&quot;,b,a,c,d);\treturn 0;&#125;\n\n计算摄氏温度给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C&#x3D;5×(F−32)&#x2F;9。题目保证输入与输出均在整型范围内。\n输入格式:输入在一行中给出一个华氏温度。\n输出格式:在一行中按照格式“Celsius &#x3D; C”输出对应的摄氏温度C的整数值。\n输入样例:150\n\n输出样例:Celsius = 65\n\n题解分析代码#include&lt;stdio.h&gt;int main() &#123;\tint C, F;\tscanf(&quot;%d&quot;, &amp;F);\tC = 5 * (F - 32) / 9;\tprintf(&quot;Celsius = %d&quot;, C);\treturn 0;&#125;\n\n整数算术运算本题要求编写程序，计算并输出2个正整数的和、差、积、商与余数。题目保证输入和输出全部在整型范围内。\n输入格式:输入在一行中给出2个正整数A和B。\n输出格式:在5行中按照格式“A 运算符 B &#x3D; 结果”顺序输出和、差、积、商与余数。\n输入样例:5 3\n\n输出样例:在这里给出相应的输出。例如：\n5 + 3 = 85 - 3 = 25 * 3 = 155 / 3 = 15 % 3 = 2\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int A,B;    scanf(&quot;%d%d&quot;,&amp;A,&amp;B);    printf(&quot;%d + %d = %d\\n&quot;,A,B,A+B);    printf(&quot;%d - %d = %d\\n&quot;,A,B,A-B);    printf(&quot;%d * %d = %d\\n&quot;,A,B,A*B);    printf(&quot;%d / %d = %d\\n&quot;,A,B,A/B);    printf(&quot;%d %% %d = %d&quot;,A,B,A%B);    return 0;&#125;\n\n8 计算火车运行时间本题要求根据火车的出发时间和达到时间，编写程序计算整个旅途所用的时间。\n输入格式：输入在一行中给出2个4位正整数，其间以空格分隔，分别表示火车的出发时间和到达时间。每个时间的格式为2位小时数（00-23）和2位分钟数（00-59），假设出发和到达在同一天内。\n输出格式：在一行输出该旅途所用的时间，格式为“hh:mm”，其中hh为2位小时数、mm为2位分钟数。\n输入样例：1201 1530\n\n输出样例：03:29\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint x, y, a, b, c, e, h, m;\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\ta = x / 100;\tb = x % 100;\tc = y / 100;\te = y % 100;\tif (b &lt;= e)\t&#123;\t\th = c - a;\t\tm = e - b;\t&#125;\telse\t&#123;\t\th = c - a - 1;\t\tm = e - b + 60;\t&#125;\tprintf(&quot;%02d:%02d&quot;, h, m);\treturn 0;&#125;\n\n题目集2密码转换输入一个大写字母，把它往后移动两个位置加密，即A变C，B变D，X变Z，Z变B\n输入格式:一行，一个大写字母\n输出格式:一行，一个大写字母\n输入样例:D\n\n输出样例:F\n\n题解分析代码#include &lt;stdio.h&gt;int main() &#123;\tchar a;\tscanf(&quot;%c&quot;, &amp;a);\tif (a == &#x27;Y&#x27;)\t&#123;\t\tprintf(&quot;A&quot;);\t&#125;\telse\t&#123;\t\tif (a == &#x27;Z&#x27;)\t\t&#123;\t\t\tprintf(&quot;B&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;%c&quot;, a + 2);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n求圆锥体体积编写程序，根据用户输入的圆锥底面半径r（整型）和高h（整型），计算圆锥体的体积。pi的取值为3.14159。 圆锥体体积的计算公式如下：\n\n输入格式:输入半径r（整型）和高h（整型）。\n输出格式:输出圆锥体体积，结果保留2位小数。\n输入样例:10 15\n\n输出样例:v=1570.79\n\n题解分析代码#include&lt;stdio.h&gt;#define PI 3.14159int main ()&#123;    int r,h;    double v;    scanf(&quot;%d%d&quot;,&amp;r,&amp;h);    v=PI*r*r*h/3;    printf(&quot;v=%.2lf&quot;,v);    return 0;&#125;\n\n组合一个新的整数编写程序输入4个一位的非负整数，依次作为个、十、百、千位组合成一个新的整数，最后输出结果。\n输入格式:在一行中输入4个一位非负整数，以空格分隔。\n输出格式:输出组合成的新整数，最后换行。\n输入样例:1 3 6 9\n\n输出样例:在这里给出相应的输出。例如：\n9631\n\n题解分析代码#include&lt;stdio.h&gt;int main ()&#123;    unsigned int a,b,c,d;    int sum=0;    scanf(&quot;%u%u%u%u&quot;,&amp;a,&amp;b,&amp;c,&amp;d);    sum=d;    sum=sum*10+c;    sum=sum*10+b;    sum=sum*10+a;    printf(&quot;%d&quot;,sum);    return 0;&#125;\n\n程序员二战后期，催生了世上第一台通用型计算机——“ENIAC”的开发。关于ENIAC，很少有人知道，ENIAC的诞生离不开6位女程序员。她们是Jean Bartik、Kathleen Antonelli、Ruth Teitelbaum、Frances Spence、Marlyn Meltzer和Betty Holberton，她们在ENIAC的发明过程中，负责给机器编程。这6位女程序员虽然都是数学系的顶尖毕业生, 但面对第一台通用型电脑，没人知道怎么下手，她们有的只是一叠资料和接线图。她们在这台大家伙上不断的研究调试，每天要费力的去拔各种缆线、托盘，有时甚至需要爬进检修管道检修故障，更换损坏的零件…. 最终她们还是完成了这项艰难的任务，编出了程序让机器运作。\n程序员是一群善于学习、进取心超强的人。他们总是喜欢学习、尝试新事物，求知欲望相当强。我们常常能在程序员的身上看到不竭的激情与满满的正能量。\n1024是2的十次方，二进制计数的基本计量单位之一，因此每年的10月24日被大家亲切称为程序员节。我们知道，二进制数系统中，每个0或1就是一个位(bit)，位是数据存储的最小单位。其中8bit就称为一个字节（Byte）,1024B&#x3D;1KB，1024 KB&#x3D;1MB，1024 MB&#x3D;1GB等等。\n请根据输入的KB数，输出位数。\n输入格式:在一行中给出一个小于100的整数，表示KB数。\n输出格式:输出二进制位数。\n输入样例:10\n\n输出样例81920\n\n题解分析代码#include &lt;stdio.h&gt;int main ()&#123;    int a;    scanf(&quot;%d&quot;,&amp;a);    printf(&quot;%d&quot;,a*8*1024);    return 0;&#125;\n\n计算分段函数本题目要求计算下列分段函数g(x)的值：\n\n\n输入格式:在一行中输入实数x。\n输出格式:在一行中按“g(x) &#x3D; result”的格式输出，其中x与result都保留3位小数。\n输入样例1:在这里给出一组输入。例如：\n500\n\n输出样例1:在这里给出相应的输出。例如：\ng(500.000) = 0.001\n\n输入样例2:在这里给出一组输入。例如：\n0\n\n输出样例2:在这里给出相应的输出。例如：\ng(0.000) = 0.000\n\n题解分析代码#include&lt;stdio.h&gt;int main ()&#123;    double a,result;    scanf(&quot;%lf&quot;,&amp;a);    if(a==0) &#123;        result=a;        printf(&quot;g(%.3lf) = %.3lf&quot;,a,result);    &#125; else &#123;        result=1/a/2;        printf(&quot;g(%.3lf) = %.3lf&quot;,a,result);    &#125;    return 0;&#125;\n\nASCII码实战给出一系列字符，有大小写英文字母和其他一些字符（仅涉及ASCII打印字符，即ASCII码值&gt;&#x3D;32），现在想让你鉴别以下这些字符。如果是英文字母则输出其ASCII码值，否则输出”illegal”（不包含引号）。\n输入格式:第一行一个整数N (0 &lt;&#x3D; N &lt;&#x3D; 1000000)，表示接下来会有多少个字符。之后N行，每行一个字符。\n输出格式:对于每个字符，如果是大小写英文字母，则输出其ASCII码值，否则输出”illegal”（不包含引号）\n输入样例:在这里给出一组输入。例如：\n3Ab#\n\n输出样例:在这里给出相应的输出。例如：\n6598illegal\n\n题解分析代码#include &lt;stdio.h&gt;#define maxn 1000000int main()&#123;\tint i, n;\tscanf(&quot;%d&quot;, &amp;n);\tgetchar();\tchar s[maxn];\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tscanf(&quot;%c&quot;, &amp;s[i]);\t\tgetchar();\t&#125;\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tif (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27; || s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;)\t\t&#123;\t\t\tprintf(&quot;%d\\n&quot;, s[i]);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;illegal\\n&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n求整数均值本题要求编写程序，计算4个整数的和与平均值。题目保证输入与输出均在整型范围内。\n输入格式:输入在一行中给出4个整数，其间以空格分隔。\n输出格式:在一行中按照格式“Sum &#x3D; 和; Average &#x3D; 平均值”顺序输出和与平均值，其中平均值精确到小数点后一位。\n输入样例:1 2 3 4\n\n输出样例:Sum = 10; Average = 2.5\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int a, b, c, d;    int Sum;    double Anverage;    scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);    Sum = a + b + c + d;    Anverage = ((double)(a + b + c + d)) / 4;    printf(&quot;Sum = %d; Average = %.1lf&quot;, Sum, Anverage);    return 0;&#125;\n\n坚持的力量本题目要求计算坚持努力后达到的能力值，以第一天的能力值initial为基数，能力值相比前一天提高的值factor就是努力参数，坚持天数为day，让我们一起来看看坚持的力量。\n计算公式为result&#x3D;initial×(1+factor)^day，其中result为坚持努力后达到的能力值，initial是能力的初始值，factor是努力参数，day是坚持天数。\n输入格式:输入在一行中顺序给出一个正实数initial、一个实数factor和一个正整数day，以空格分隔。\n输出格式:在一行中按“result &#x3D; 能力值”的格式输出，其中能力值保留两位小数。请注意等号的左右各有一个空格。\n输入样例1:1.0 0.01 365\n\n输出样例1:result = 37.78\n\n输入样例2:1.0 -0.01 365\n\n输出样例2:result = 0.03\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    double initial, result,factor;    unsigned int day;    scanf(&quot;%lf %lf %u&quot;, &amp;initial, &amp;factor, &amp;day);    result = initial;    for (int i = 0; i &lt; day; i++) &#123;        result = result*(1 + factor);    &#125;    printf(&quot;result = %.2lf&quot;, result);    return 0;&#125;\n\n油桶数工人师傅将油桶码成如下图所示的梯形，数了数底层的油桶数和层数，就知道有多少油桶了。你知道他是怎么算的吗？\n\n输入格式\n底层油桶数 a 和层数 b\n\n输出格式\n油桶的数量 n\n\n输入样例100000 70000\n\n输出样例4550035000\n\n\n题解分析提示：本题要使用 long long int 类型。\n代码#include&lt;stdio.h&gt;int main()&#123;    long long int a, b;    long long int sum = 0;    scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);    sum=(a+a-b+1)*b/2;    printf(&quot;%lld&quot;, sum);    return 0;&#125;\n\n后天如果今天是星期三，后天就是星期五；如果今天是星期六，后天就是星期一。我们用数字1到7对应星期一到星期日。给定某一天，请你输出那天的“后天”是星期几。\n输入格式：输入第一行给出一个正整数D（1 ≤ D ≤ 7），代表星期里的某一天。\n输出格式：在一行中输出D天的后天是星期几。\n输入样例：3\n\n输出样例：5\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;int a,b,c;scanf(&quot;%d&quot;,&amp;a);  if(a+2&gt;7)&#123;    b=a+2;    c=b%7;    printf(&quot;%d\\n&quot;,c);&#125;  else&#123;     c=a+2;  printf(&quot;%d\\n&quot;,c);&#125;return 0;&#125;\n\n题目集3判断能否被3，5，7整除任务描述给定一个整数，判断它能否被3，5，7整除，并输出以下信息：1、能同时被3，5，7整除（直接输出3 5 7，每个数中间一个空格）；2、只能被其中两个数整除（输出两个数，小的在前，大的在后。例如：3 5或者 3 7或者5 7,中间用空格分隔）；3、只能被其中一个数整除（输出这个数）；4、不能被3、5、7中任何数整除，输出小写字符‘n’,不包括单引号。\n\n输入格式:输入一行，包括一个整数。\n输出格式:输出一行，按照描述要求给出整数被3，5，7整除的情况。\n输入样例1:105\n\n输出样例1:3 5 7\n\n输入样例2:15\n\n输出样例2:3 5\n\n输入样例3:17\n\n输出样例3:n\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint a;\tscanf(&quot;%d&quot;, &amp;a);\tif (a % 3 == 0&amp;&amp; a % 5 == 0&amp;&amp; a % 7 == 0)\t\tprintf(&quot;3 5 7&quot;);\tif (a % 3 != 0 &amp;&amp; a % 5 == 0 &amp;&amp; a % 7 == 0)\t\tprintf(&quot;5 7&quot;);\tif (a % 3 == 0 &amp;&amp; a % 5 != 0 &amp;&amp; a % 7 == 0)\t\tprintf(&quot;3 7&quot;);\tif (a % 3 == 0 &amp;&amp; a % 5 == 0 &amp;&amp; a % 7 != 0)\t\tprintf(&quot;3 5&quot;);\tif (a % 3 != 0 &amp;&amp; a % 5 != 0 &amp;&amp; a % 7 == 0)\t\tprintf(&quot;7&quot;);\tif (a % 3 != 0 &amp;&amp; a % 5 == 0 &amp;&amp; a % 7 != 0)\t\tprintf(&quot;5&quot;);\tif (a % 3 == 0 &amp;&amp; a % 5 != 0 &amp;&amp; a % 7 != 0)\t\tprintf(&quot;3&quot;);\tif (a % 3 != 0 &amp;&amp; a % 5 != 0 &amp;&amp; a % 7 != 0)\t\tprintf(&quot;n&quot;);\treturn 0;&#125;\n\n阶梯水价为了提倡居民节约用电，某省电力公司执行“阶梯电价”，安装一户一表的居民用户电价分为两个“阶梯”：月用电量50千瓦时（含50千瓦时）以内的，电价为0.53元&#x2F;千瓦时；超过50千瓦时的，超出部分的用电量，电价上调0.05元&#x2F;千瓦时。请编写程序计算电费。\n输入格式:输入在一行中给出某用户的月用电量（单位：千瓦时）。\n输出格式:在一行中输出该用户应支付的电费（元），结果保留两位小数，格式如：“cost &#x3D; 应付电费值”；若用电量小于0，则输出”Invalid Value!”。\n输入样例1:10\n\n输出样例1:cost = 5.30\n\n输入样例2:100\n\n输出样例2:cost = 55.50\n\n题解分析代码#include&lt;stdio.h&gt;int main ()&#123;    double a,cost;    scanf(&quot;%lf&quot;,&amp;a);    if (a&lt;0)     &#123;        printf(&quot;Invalid Value!&quot;);    &#125;    else    &#123;        if (a&gt;=0&amp;&amp;a&lt;=50)        &#123;            cost=0.53*a;            printf(&quot;cost = %.2lf&quot;,cost);        &#125;        else        &#123;            cost=0.58*a-2.5;            printf(&quot;cost = %.2lf&quot;,cost);        &#125;    &#125;    return 0;&#125;\n\n有一门课不及格的学生任务描述给出一名学生的语文和数学成绩，判断他是否恰好有一门课不及格（成绩小于60分）。\n输入格式:一行，包含两个在0到100之间的整数，分别是该生的语文成绩和数学成绩。\n输出格式:若该生恰好有一门课不及格，输出1；否则输出0。\n输入样例:50 80\n\n输出样例:1\n\n提示此题目考察“恰好有一门课不及格”的判别表达式，请注意括号在复杂逻辑表达式中的作用。\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;    int a, b;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    if (a &gt;= 60 &amp;&amp; b &lt; 60 || a &lt; 60 &amp;&amp; b &gt;= 60)    \tprintf(&quot;1&quot;);    else        printf(&quot;0&quot;);    return 0;&#125;\n\n胎压监测题目小轿车中有一个系统随时监测四个车轮的胎压，如果四轮胎压不是很平衡，则可能对行车造成严重的影响。\n\n让我们把四个车轮 —— 左前轮、右前轮、右后轮、左后轮 —— 顺次编号为 1、2、3、4。本题就请你编写一个监测程序，随时监测四轮的胎压，并给出正确的报警信息。报警规则如下：\n\n如果所有轮胎的压力值与它们中的最大值误差在一个给定阈值内，并且都不低于系统设定的最低报警胎压，则说明情况正常，不报警；\n如果存在一个轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则不仅要报警，而且要给出可能漏气的轮胎的准确位置；\n如果存在两个或两个以上轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则报警要求检查所有轮胎。\n\n输入格式：输入在一行中给出 6 个 [0, 400] 范围内的整数，依次为 1~4 号轮胎的胎压、最低报警胎压、以及胎压差的阈值。\n输出格式：根据输入的胎压值给出对应信息：\n\n如果不用报警，输出 Normal；\n如果有一个轮胎需要报警，输出 Warning: please check #X!，其中 X 是出问题的轮胎的编号；\n如果需要检查所有轮胎，输出 Warning: please check all the tires!。\n\n输入样例 1：242 251 231 248 230 20\n\n输出样例 1：Normal\n\n输入样例 2：242 251 232 248 230 10\n\n输出样例 2：Warning: please check #3!\n\n输入样例 3：240 251 232 248 240 10\n\n输出样例 3：Warning: please check all the tires!\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint a[4],max_a,max,min,count=0;\t//max_a为差值  max为阈值  min为最低气压 count为轮胎编号\tscanf(&quot;%d %d %d %d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3], &amp;min, &amp;max);\tmax_a = a[0];\tfor (int i = 1; i &lt; 4; i++)\t&#123;\t\tif (max_a&lt;a[i])\t\t&#123;\t\t\tmax_a = a[i];\t\t&#125;\t&#125;\tint number=0;\tfor (int  i = 0; i &lt; 4; i++)\t&#123;\t\tif (a[i]&lt;min||max_a-a[i]&gt;max)\t\t&#123;\t\t\tcount++;\t\t\tnumber = i + 1;\t\t&#125;\t&#125;\tif (count == 0)printf(&quot;Normal&quot;);\tif (count == 1)printf(&quot;Warning: please check #%d!&quot;, number);\tif (count &gt;= 2)printf(&quot;Warning: please check all the tires!&quot;);\t\treturn 0;&#125;\n\n前世档案题目\n网络世界中时常会遇到这类滑稽的算命小程序，实现原理很简单，随便设计几个问题，根据玩家对每个问题的回答选择一条判断树中的路径（如下图所示），结论就是路径终点对应的那个结点。\n\n现在我们把结论从左到右顺序编号，编号从 1 开始。这里假设回答都是简单的“是”或“否”，又假设回答“是”对应向左的路径，回答“否”对应向右的路径。给定玩家的一系列回答，请你返回其得到的结论的编号。\n输入格式：输入第一行给出两个正整数：N（≤30）为玩家做一次测试要回答的问题数量；M（≤100）为玩家人数。\n随后 M 行，每行顺次给出玩家的 N 个回答。这里用 y 代表“是”，用 n 代表“否”。\n输出格式：对每个玩家，在一行中输出其对应的结论的编号。\n输入样例：3 4ynynyynynyyn\n\n输出样例：3562\n\n题解分析代码#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123;\t//N为做题数目，M为玩家人数\tint N, M, i, j;\tchar str[31];//储存玩家的回答\tint a[100] = &#123; 0 &#125;;//储存对应的十进制数\tscanf(&quot;%d %d&quot;, &amp;N, &amp;M);\tgetchar();//用来吸收 输入完成后的那个回车\tfor (i = 0; i &lt; M; i++)\t&#123;\t\t\t\ta[i] = 1;//换行也算一个字符\t\tfor (j = 0; j &lt; N; j++)\t\t&#123;\t\t\tscanf(&quot;%c&quot;, &amp;str[j]);\t\t\tif (str[j] == &#x27;n&#x27;)\t\t\t&#123;\t\t\t\ta[i] += pow(2, (N - 1 - j));\t\t\t&#125;\t\t&#125;\t\tif (i!=(M-1))\t\t&#123;\t\t\tgetchar();//与上面的同理\t\t&#125;\t&#125;\tfor (j = 0; j &lt; i; j++)\t\tprintf(&quot;%d\\n&quot;, a[j]);\treturn 0;&#125;\n\n解一元二次方程题目请编写程序，解一元一次方程 ax2+bx+c&#x3D;0 。\n已知一元二次方程的求根公式为：\n\n要求：\n(1) 若 a&#x3D;0，则为一元一次方程。\n\n若 b&#x3D;0，则方程有唯一解，输出这个解；\n若 b&#x3D;0,c&#x3D;0，则方程无解，输出“无解”；\n若 b&#x3D;0,c&#x3D;0，则方程有无穷多解，输出“无穷多解”。\n\n(2) 若 a&#x3D;0，则为一元二次方程。\n\n若 Δ&gt;0，则方程有两个不等的实根，输出这两个根；\n若 Δ&#x3D;0，则方程有两个相等的实根，输出这两个根；\n若 Δ&lt;0，则方程有两个共轭的虚根，输出这两个根。\n\n输入格式a,b,c\n\n输出格式x 或 x1,x2\n\n注：所有实数均输出6位有效数字，且不输出末尾无意义的0和小数点。\n输入样例10 4.5 -3.6\n\n输出样例1x = 0.8\n\n输入样例20 2.8 0\n\n输出样例2x = 0\n\n输入样例30 0 3.6\n\n输出样例3无解\n\n输入样例40 0 0\n\n输出样例4无穷多解\n\n输入样例5-2 0.8 -0.06\n\n输出样例5x1 = 0.1, x2 = 0.3\n\n输入样例6-1 0.2 0\n\n输出样例6x1 = 0, x2 = 0.2\n\n输入样例71 -0.4 0.04\n\n输出样例7x1 = x2 = 0.2\n\n输入样例80.3 0 0\n\n输出样例8x1 = x2 = 0\n\n输入样例9-0.2 0.04 -0.01\n\n输出样例9x1 = 0.1-0.2i, x2 = 0.1+0.2i\n\n输入样例103 0 0.27\n\n输出样例10x1 = 0+0.3i, x2 = 0-0.3i\n\n提示：注意实数的负零问题和误差问题。\n题解分析代码#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define I 1e-10int main()&#123;\tdouble a, b, c,d,X1,X2;//d=b*b-4*a*c\tscanf(&quot;%lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c);\t//判断是否为一元一次方程\tif (a==0)//一元一次方程\t&#123;\t\t//判断b是否为0\t\tif (b!=0)//b不等于0的情况\t\t&#123;\t\t\tif (c==0)\t\t\t&#123;\t\t\t\tprintf(&quot;x = 0&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;x = %g&quot;, (-c) / b);\t\t\t&#125;\t\t&#125;\t\telse//b等于0的情况\t\t&#123;\t\t\t//判断c是否为0\t\t\tif (c==0)//c为0\t\t\t&#123;\t\t\t\tprintf(&quot;无穷多解&quot;);\t\t\t&#125;\t\t\telse//c不为0\t\t\t&#123;\t\t\t\tprintf(&quot;无解&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\telse//一元二次方程\t&#123;\t\t//计算Δ\t\td = b * b - 4 * a * c;\t\t//判断Δ的正负\t\tif (d&gt;I)//Δ&gt;0\t\t&#123;\t\t\td = sqrt(d);\t\t\tif ((-b+d)==0)\t\t\t&#123;\t\t\t\tprintf(&quot;x1 = 0, x2 = %g&quot;, (-b - d) / (2 * a));\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;x1 = %g, x2 = %g&quot;, (-b + d) / (2 * a), (-b - d) / (2 * a));\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tif (fabs(d)&lt;I)//Δ=0\t\t\t&#123;\t\t\t\t//判断b是否为0，否则输出时可能输出-0\t\t\t\tif (b==0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;x1 = x2 = 0&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tX1 = (-b) / (2 * a);\t\t\t\t\tprintf(&quot;x1 = x2 = %g&quot;, X1);\t\t\t\t&#125;\t\t\t&#125;\t\t\telse//Δ&lt;0\t\t\t&#123;\t\t\t\td = sqrt(-d);\t\t\t\t//判断b是否为0，否则输出时可能输出-0\t\t\t\tif (b==0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;x1 = 0+%gi, x2 = 0-%gi&quot;, d / (2 * a), d / (2 * a));\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;x1 = %g+%gi, x2 = %g-%gi&quot;, (-b) / (2 * a), d / (2 * a), (-b) / (2 * a), d / (2 * a));\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n某月天数题目编程输入年份和月份，输出这一年的这个月份有多少天。\n输入样例:2015 10\n\n输出样例:31\n\n输入样例:2016 2\n\n输出样例:29\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint year, month, result;\tscanf(&quot;%d %d&quot;, &amp;year, &amp;month);    int array[12] = &#123; 31,(year % 4 == 0 &amp;&amp; year % 100 != 0) ? 29 : 28 ,31,30,31,30,31,31,30,31,30,31 &#125;;\tprintf(&quot;%d&quot;, array[month-1]);\treturn 0;&#125;\n\n洛希极限题目科幻电影《流浪地球》中一个重要的情节是地球距离木星太近时，大气开始被木星吸走，而随着不断接近地木“刚体洛希极限”，地球面临被彻底撕碎的危险。但实际上，这个计算是错误的。\n\n洛希极限（Roche limit）是一个天体自身的引力与第二个天体造成的潮汐力相等时的距离。当两个天体的距离少于洛希极限，天体就会倾向碎散，继而成为第二个天体的环。它以首位计算这个极限的人爱德华·洛希命名。（摘自百度百科）\n大天体密度与小天体的密度的比值开 3 次方后，再乘以大天体的半径以及一个倍数（流体对应的倍数是 2.455，刚体对应的倍数是 1.26），就是洛希极限的值。例如木星与地球的密度比值开 3 次方是 0.622，如果假设地球是流体，那么洛希极限就是 0.622×2.455&#x3D;1.52701 倍木星半径；但地球是刚体，对应的洛希极限是 0.622×1.26&#x3D;0.78372 倍木星半径，这个距离比木星半径小，即只有当地球位于木星内部的时候才会被撕碎，换言之，就是地球不可能被撕碎。\n本题就请你判断一个小天体会不会被一个大天体撕碎。\n输入格式：输入在一行中给出 3 个数字，依次为：大天体密度与小天体的密度的比值开 3 次方后计算出的值（≤1）、小天体的属性（0 表示流体、1 表示刚体）、两个天体的距离与大天体半径的比值（&gt;1 但不超过 10）。\n输出格式：在一行中首先输出小天体的洛希极限与大天体半径的比值（输出小数点后2位）；随后空一格；最后输出 ^_^ 如果小天体不会被撕碎，否则输出 T_T。\n输入样例 1：0.622 0 1.4\n\n输出样例 1：1.53 T_T\n\n输入样例 2：0.622 1 1.4\n\n输出样例 2：0.78 ^_^\n\n题解分析代码#include&lt;stdio.h&gt;int main ()&#123;    double a,c;    int b;    scanf(&quot;%lf %d %lf&quot;,&amp;a,&amp;b,&amp;c);    double array[2]=&#123;2.455,1.26&#125;;    (a*array[b]&lt;c)?printf(&quot;%.2lf ^_^&quot;,a*array[b]):printf(&quot;%.2lf T_T&quot;,a*array[b]);    return 0;&#125;\n\n吃鱼还是吃肉题目国家给出了 8 岁男宝宝的标准身高为 130 厘米、标准体重为 27 公斤；8 岁女宝宝的标准身高为 129 厘米、标准体重为 25 公斤。\n现在你要根据小宝宝的身高体重，给出补充营养的建议。\n输入格式：输入在第一行给出一个不超过 10 的正整数 N，随后 N 行，每行给出一位宝宝的身体数据：\n性别 身高 体重\n\n其中性别是 1 表示男生，0 表示女生。身高和体重都是不超过 200 的正整数。\n输出格式：对于每一位宝宝，在一行中给出你的建议：\n\n如果太矮了，输出：duo chi yu!（多吃鱼）；\n如果太瘦了，输出：duo chi rou!（多吃肉）；\n如果正标准，输出：wan mei!（完美）；\n如果太高了，输出：ni li hai!（你厉害）；\n如果太胖了，输出：shao chi rou!（少吃肉）。\n\n先评价身高，再评价体重。两句话之间要有 1 个空格。\n输入样例：40 130 231 129 271 130 300 128 27\n\n输出样例：ni li hai! duo chi rou!duo chi yu! wan mei!wan mei! shao chi rou!duo chi yu! shao chi rou!\n\n题解分析还可以使用结构体数组来写代码\n代码#include&lt;stdio.h&gt;int main()&#123;\tint array [10][3] = &#123; &#123;0,0&#125; &#125;;\tint a;\tscanf(&quot;%d&quot;,&amp;a);\tfor (int i = 0; i &lt; a; i++)\t&#123;\t\tscanf(&quot;%d %d %d&quot;, &amp;array[i][0], &amp;array[i][1], &amp;array[i][2]);\t&#125;\tfor (int i = 0; i &lt; a; i++)\t&#123;\t\tif (array[i][0]==0)\t\t&#123;\t\t\tif (array[i][1]&gt;129)\t\t\t&#123;\t\t\t\tprintf(&quot;ni li hai! &quot;);\t\t\t\tif (array[i][2]&gt;25)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tif (array[i][2]&lt;25)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (array[i][1]&lt;129)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;duo chi yu! &quot;);\t\t\t\t\tif (array[i][2] &gt; 25)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tif (array[i][2] &lt; 25)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;wan mei! &quot;);\t\t\t\t\tif (array[i][2] &gt; 25)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tif (array[i][2] &lt; 25)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tif (array[i][1] &gt; 130)\t\t\t&#123;\t\t\t\tprintf(&quot;ni li hai! &quot;);\t\t\t\tif (array[i][2] &gt; 27)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tif (array[i][2] &lt; 27)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (array[i][1] &lt; 130)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;duo chi yu! &quot;);\t\t\t\t\tif (array[i][2] &gt; 27)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tif (array[i][2] &lt; 27)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;wan mei! &quot;);\t\t\t\t\tif (array[i][2] &gt; 27)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;shao chi rou!\\n&quot;);\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tif (array[i][2] &lt; 27)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;duo chi rou!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;wan mei!\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n念数字题目输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下：\n0: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu\n\n输入格式：输入在一行中给出一个整数，如：1234。\n提示：整数包括负数、零和正数。\n输出格式：在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如yi er san si。\n输入样例：-600\n\n输出样例：fu liu ling ling\n\n题解分析代码#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;\tchar c[100]=&#123;&#x27;\\0&#x27;&#125;;\tint i=0;\tgets(c);\ti = strlen(c);\tfor (int j=0;j&lt;i; j++)\t&#123;\t\tswitch (c[j])\t\t&#123;\t\tcase &#x27;-&#x27;:\t\t\tprintf(&quot;fu&quot;);\t\t\tbreak;\t\tcase &#x27;1&#x27;:\t\t\tprintf(&quot;yi&quot;);\t\t\tbreak;\t\tcase &#x27;2&#x27;:\t\t\tprintf(&quot;er&quot;);\t\t\tbreak;\t\tcase &#x27;3&#x27;:\t\t\tprintf(&quot;san&quot;);\t\t\tbreak;\t\tcase &#x27;4&#x27;:\t\t\tprintf(&quot;si&quot;);\t\t\tbreak;\t\tcase &#x27;5&#x27;:\t\t\tprintf(&quot;wu&quot;); \t\t\tbreak;\t\tcase &#x27;6&#x27;:\t\t\tprintf(&quot;liu&quot;); \t\t\tbreak;\t\tcase &#x27;7&#x27;:\t\t\tprintf(&quot;qi&quot;); \t\t\tbreak;\t\tcase &#x27;8&#x27;:\t\t\tprintf(&quot;ba&quot;); \t\t\tbreak;\t\tcase &#x27;9&#x27;:\t\t\tprintf(&quot;jiu&quot;); \t\t\tbreak;\t\tcase &#x27;0&#x27;:\t\t\tprintf(&quot;ling&quot;);\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t&#125;\t\tif (j&lt;i-1)\t\t&#123;\t\t\tprintf(&quot; &quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n题目集4求平方根序列前N项和题目本题要求编写程序，计算平方根序列根号1+根号2+….的前N项之和。可包含头文件math.h，并调用sqrt函数求平方根。\n输入格式:输入在一行中给出一个正整数N。\n输出格式:在一行中按照“sum &#x3D; S”的格式输出部分和的值S，精确到小数点后两位。题目保证计算结果不超过双精度范围。\n输入样例:10\n\n输出样例:sum = 22.47\n\n题解分析代码#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123;\tint i,n;\tdouble S,sum;\tscanf(&quot;%d&quot;,&amp;n);\tsum = 0;\tfor(i = 1;i &lt;= n;i++)&#123;\tS = sqrt(i);\tsum = sum + S;&#125;\t\tprintf(&quot;sum = %.2f&quot;,sum);\treturn 0;&#125;\n猜数字游戏题目猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。\n输入格式:输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。\n输出格式:在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。\n输入样例:58 47050565860-2\n\n输出样例:Too bigToo smallToo smallGood Guess!\n\n题解分析代码#include&quot;stdio.h&quot;int main(void)&#123;    //number为产生的随机数，times为设置的最大的猜测次数，guess则为玩家猜测的数，guesstimes为猜测次数        int number, times, guesstimes=0,guess;        scanf(&quot;%d %d&quot;, &amp;number, &amp;times);        while (1)&#123;             scanf(&quot;%d&quot;, &amp;guess);        guesstimes++;        if ((guesstimes &gt;times)|| (guess &lt; 0 &amp;&amp; guesstimes &lt;= times))        &#123;    //猜测的次数大于了提前设置的次数，或者是猜测不符合题目且在猜测次数里。         printf(&quot;Game Over\\n&quot;);        return 0;//结束        &#125;        if (guess &gt; number)        &#123;            printf(&quot;Too big\\n&quot;);       &#125;        if (guess &lt; number )       &#123;            printf(&quot;Too small\\n&quot;);       &#125;   if (guess == number) //将等于的情况的单独分离       &#123;           if (guesstimes == 1)        &#123;            printf(&quot;Bingo!\\n&quot;);       &#125;      else if (guesstimes &lt;= 3)           &#123;             printf(&quot;Lucky You!\\n&quot;);          &#125;      else &#123;             printf(&quot;Good Guess!\\n&quot;);           &#125;   return 0;//通过return 0结束循环，或者说直接终止函数       &#125;                    &#125;//while的大括号&#125;\n\n求e的近似值题目自然常数 e 可以用级数 1+1&#x2F;1!+1&#x2F;2!+⋯+1&#x2F;n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。\n输入格式:输入第一行中给出非负整数 n（≤1000）。\n输出格式:在一行中输出部分和的值，保留小数点后八位。\n输入样例:10\n\n输出样例:2.71828180\n\n题解分析代码#include&lt;stdio.h&gt;double calculate_factorial(double number);int main ()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    double result=1;    for (int i=1;i&lt;=n;i++)    &#123;        result+=(1.0/calculate_factorial(i));    &#125;    printf(&quot;%.8lf&quot;,result);&#125;double calculate_factorial(double number)&#123;    double sum=1;    if(number==0||number==1)    &#123;        return 1;    &#125;    for(int i=1;i&lt;=number;i++)    &#123;        sum*=i;    &#125;    return sum;&#125;\n三天打鱼两天晒网题目中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？\n输入格式：输入在一行中给出一个不超过1000的正整数N。\n输出格式：在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。\n输入样例1：103\n\n输出样例1：Fishing in day 103\n\n输入样例2：34\n\n输出样例2：Drying in day 34\n\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    if ((n%5&gt;0)&amp;&amp;(n%5&lt;=3))    &#123;        printf(&quot;Fishing in day %d&quot;,n);    &#125;    else    &#123;        printf(&quot;Drying in day %d&quot;,n);    &#125;        return 0;&#125;\n\n求整数的位数及各位数字之和题目对于给定的正整数N，求它的位数及其各位数字之和。\n输入格式：输入在一行中给出一个不超过109的正整数N。\n输出格式：在一行中输出N的位数及其各位数字之和，中间用一个空格隔开。\n输入样例：321\n\n输出样例：3 6\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint number, digits_number=0, sum=0;\tscanf(&quot;%d&quot;, &amp;number);\twhile (number&gt;0)\t&#123;\t\tsum += number % 10;\t\tnumber = number / 10;\t\tdigits_number++;\t&#125;\tprintf(&quot;%d %d&quot;, digits_number, sum);\treturn 0;&#125;\n查验身份证题目一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：\n首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：\nZ：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2\n\n现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。\n输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。\n输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。\n输入样例1：432012419880824005612010X19890101123411010819671130186637070419881216001X\n\n输出样例1：12010X19890101123411010819671130186637070419881216001X\n\n输入样例2：2320124198808240056110108196711301862\n\n输出样例2：All passed\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint array1[17] = &#123; 7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2 &#125;;\tint N,sum,false=0;\tchar str[19];\tchar array2[11] = &#123; &#x27;1&#x27;,&#x27;0&#x27;,&#x27;X&#x27;,&#x27;9&#x27;,&#x27;8&#x27;,&#x27;7&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27; &#125;;\tscanf(&quot;%d&quot;, &amp;N);\t//getchar();\tfor (int i = 0; i &lt; N; i++)\t&#123;        sum=0;\t\tscanf(&quot;%s&quot;, str);\t\tfor (int j = 0; j &lt; 17; j++)\t\t&#123;\t\t\tsum += (str[j] - &#x27;0&#x27;) * array1[j];\t\t&#125;\t\tsum = sum % 11;\t\tif (array2[sum]!=str[17])\t\t&#123;\t\t\tprintf(&quot;%s\\n&quot;, str);\t\t\tfalse=1;\t\t&#125;\t&#125;\tif (false==0)\t&#123;\t\tprintf(&quot;All passed\\n&quot;);\t&#125;\treturn 0;&#125;\n\n找出最小值题目本题要求编写程序，找出给定一系列整数中的最小值。\n输入格式：输入在一行中首先给出一个正整数n，之后是n个整数，其间以空格分隔。\n输出格式：在一行中按照“min &#x3D; 最小值”的格式输出n个整数中的最小值。\n输入样例：4 -2 -123 100 0\n\n输出样例：min = -123\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int min;    int n;//输入n个数    scanf(&quot;%d &quot;,&amp;n);    int num;    scanf(&quot;%d &quot;,&amp;num);    min = num;//先把第一个当成最小的    for(int x = 1;x&lt;=n-1;x++)//只循环n-1次    &#123;        scanf(&quot;%d &quot;,&amp;num);        if(min&gt;num)        &#123;            min = num;        &#125;    &#125;    printf(&quot;min = %d&quot;,min);    return 0;&#125;\n\n统计闰年个数题目现行格里高利历法的置闰规则可以概括为：四闰百不闰，四百闰。编程序实现：输入一个年份，求出到这一年的年底总共经历了多少个闰年，限定不能使用循环结构。假定从公元第一天开始，就实施格里高利历法。（提示：求出经历了多少个4年、多少个100年、多少个400年。）\n输入格式:输入一个代表年份的正整数。\n输出格式:输出闰年个数，最后换行。\n输入样例:2020\n\n输出样例:490\n\n题解分析代码#include &lt;stdio.h&gt;int main ()&#123;    int input_num,leap_year_total;    scanf (&quot;%d&quot;,&amp;input_num) ;    leap_year_total = input_num/4-input_num/100+input_num/400 ;    printf(&quot;%d\\n&quot;,leap_year_total);    return 0;&#125;\n\n一道几何题题目众所周知，坠帅坠可爱的ZZZ学长是计算几何的大师，这次他遇到了这样一个题目。给定3个点a，b，c。找到一个点，使得如果我们把平面绕着这个点旋转一定的角度，a可以落在b原来的位置，同时b也落在c原来的位置。ZZZ知道这个问题不一定有解，但是他把如何判断是否有解的问题留给了你，试试看吧！        提示将整个平面绕(0.5,0.5)旋转90°就行了 \n\n输入格式:6个整数分别表示a，b，c的横坐标和纵坐标，（横纵坐标绝对值的范围不会超过10的9次方）这三个点不会互相重合的\n输出格式:如果有解的话，输出yes，无解的话，输出no\n输入样例:在这里给出一组输入。例如：\n0 1 1 1 1 0\n\n输出样例:在这里给出相应的输出。例如：\nyes\n\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;    double coordx_a, coordx_b, coordx_c, coordy_a, coordy_b, coordy_c, coordx, coordy;    double flag = 0, length_ab, length_bc;    scanf(&quot;%lf %lf %lf %lf %lf %lf&quot;, &amp;coordx_a, &amp;coordy_a, &amp;coordx_b, &amp;coordy_b, &amp;coordx_c, &amp;coordy_c);    length_ab = (coordx_a - coordx_b) * (coordx_a - coordx_b) + (coordy_a - coordy_b) * (coordy_a - coordy_b);    length_bc = (coordx_c - coordx_b) * (coordx_c - coordx_b) + (coordy_c - coordy_b) * (coordy_c - coordy_b);    if (length_ab == length_bc)    &#123;        if ((coordy_b - coordy_a) * (coordx_c - coordx_a) != (coordy_c - coordy_a) * (coordx_b - coordx_a))        &#123;            flag = 1;        &#125;    &#125;    if (flag)    &#123;        printf(&quot;yes\\n&quot;);    &#125;    else    &#123;        printf(&quot;no\\n&quot;);    &#125;    return 0;&#125;\n\n计算区间素数和题目杨老师正在上《离散数学》课程的“数论”内容，讲授素数的知识。素数又称为质数。一个大于1的整数p是素数，当且仅当p只能被1和自身整除。很显然，2是最小的素数。他想设计一个程序，可以计算整数 m 和 n 之间的所有素数之和。\n输入格式:输入两个整数 m,n, 题目不保证 m≤n，但是保证 0≤m≤20000,0≤n≤20000。\n输出格式:输出 m 和 n 之间的所有素数的和。\n输入样例01:在这里给出一组输入。例如：\n10 0\n\n输出样例01:在这里给出相应的输出。例如：\n17\n\n输入样例02:在这里给出一组输入。例如：\n100 200\n\n输出样例02:在这里给出相应的输出。例如：\n3167\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;\tint input_num_m, input_num_n, c;\tint sum = 0;\tscanf(&quot;%d %d&quot;, &amp;input_num_m, &amp;input_num_n);\tif (input_num_m &gt; input_num_n)\t&#123;\t\tc = input_num_m;\t\tinput_num_m = input_num_n;\t\tinput_num_n = c;\t&#125;\tfor (int a = input_num_m; a &lt;= input_num_n; a++)\t&#123;        int isprime = 1;        if (a&lt;2)        &#123;            isprime=0;        &#125;        for (int i = 2; i &lt;= sqrt(a); i++)\t\t&#123;\t\t\tif (a % i == 0)\t\t\t&#123;\t\t\t\tisprime = 0;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tif (isprime == 1)\t\t&#123;\t\t\tsum += a;\t\t&#125;\t&#125;\tprintf(&quot;%d&quot;, sum);\treturn 0;&#125;\n\n3206 化验诊断题目下表是进行血常规检验的正常值参考范围，及化验值异常的临床意义：\n血常规检验正常值参考范围列表\n\n给定一张化验单，判断其所有指标是否正常，如果不正常，统计有几项不正常。化验单上的值必须严格落在正常参考值范围内，才算是正常。正常参考值范围包括边界，即落在边界上也算正常。\n输入格式:输入的第一行包含一个正整数k(0 &lt; k &lt; 100)，表示有k组测试数据；接下来k行，每行包含一组测试数据。每组测试数据第一项是一个英文单词（male，男或者female，女），表示受测者的性别；第二项是白细胞的值（以109&#x2F;L为单位）；第三项是红细胞的值（以1012&#x2F;L为单位）；第四项是血红蛋白的值（以g&#x2F;L为单位）；第五项是红细胞比积的值（以%为单位）；第六项是血小板计数的值（以109&#x2F;L为单位）。每两项用一个空格分开。\n输出格式:对于每组测试数据，输出一行。如果所有检验项目正常，则输出：normal；否则输出不正常的项的数目。\n输入样例:2female 4.5 4.0 115 37 200male 3.9 3.5 155 36 301\n\n输出样例:normal3\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;    int total_data, count;    char str[8];    double array_blood_routine[5];    scanf(&quot;%d&quot;, &amp;total_data);        for (int j = 0; j &lt; total_data; j++)    &#123;        scanf(&quot;%s&quot;,str);        count = 0;        for (int i = 0; i &lt; 5; i++)        &#123;            scanf(&quot;%lf&quot;, &amp;array_blood_routine[i]);        &#125;        if (strcmp(str,&quot;male&quot;)==0)        &#123;            if ((array_blood_routine[0] &gt; 10.0 || array_blood_routine[0] &lt; 4.0))            &#123;                count++;            &#125;            if ((array_blood_routine[1] &gt; 5.5 || array_blood_routine[1] &lt; 3.5))            &#123;                count++;            &#125;            if ((array_blood_routine[2] &gt; 160 || array_blood_routine[2] &lt; 120))            &#123;                count++;            &#125;            if ((array_blood_routine[3] &gt; 48 || array_blood_routine[3] &lt; 42))            &#123;                count++;            &#125;            if ((array_blood_routine[4] &gt; 300 || array_blood_routine[4] &lt; 100))            &#123;                count++;            &#125;        &#125;        else        &#123;            if ((array_blood_routine[0] &gt; 10.0 || array_blood_routine[0] &lt; 4.0))            &#123;                count++;            &#125;            if ((array_blood_routine[1] &gt; 5.5 || array_blood_routine[1] &lt; 3.5))            &#123;                count++;            &#125;            if ((array_blood_routine[2] &gt; 150 || array_blood_routine[2] &lt; 110))            &#123;                count++;            &#125;            if ((array_blood_routine[3] &gt; 40 || array_blood_routine[3] &lt; 36))            &#123;                count++;            &#125;            if ((array_blood_routine[4] &gt; 300 || array_blood_routine[4] &lt; 100))            &#123;                count++;            &#125;        &#125;        if (count)        &#123;            printf(&quot;%d\\n&quot;, count);        &#125;        else        &#123;            printf(&quot;normal\\n&quot;);        &#125;    &#125;        return 0;&#125;\n\n尼科彻斯定理题目验证尼科彻斯定理，即：任何一个正整数 N 的立方都可以写成 N 个连续奇数之和。(首个奇数是：N*N-N+1)\n输入格式:任一正整数N。\n输出格式:该数的立方分解为一串连续奇数的和。\n输入样例:13\n\n输出样例:13*13*13=2197=157+159+161+163+165+167+169+171+173+175+177+179+181\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int n, a, i;    scanf(&quot;%d&quot;, &amp;n);    a = n * n - n + 1;    printf(&quot;%d*%d*%d=%d=%d&quot;, n, n, n, n * n * n, a);    for (i = 1; i &lt; n; i++)    &#123;        printf(&quot;+%d&quot;, a + i * 2);    &#125;    return 0;&#125;\n\nGPA题目输入格式:输入的第一行包含一个整数n表示A的课程数，以下n行每行Si,Ci分别表示第i个课程的学分与A的表现。\nGPA&#x3D;Σ(Si*Ci) &#x2F; Σ(Si)。\n特殊地，如果Ci是’P’或者’N’（对应于通过与不通过），则第i个课程不记入GPA的计算（即当其不存在）。\nA读入结束后读入B，B的输入格式与A相同。\n保证2人的Σ(Si)非零\n输出格式:输出A的GPA - B的GPA的值，保留2位小数（四舍五入）\nTips：当A和B的分数相近时输出0.00。\n输入样例:21 102 N21 101 5\n\n输出样例:2.50\n\n数据规模和约定输入的所有数字均为不超过100的非负整数\n题解分析代码#include&lt;stdio.h&gt;int main() &#123;\tint n;\t\t\t//学科数目 \tfloat Sa = 0, Sb = 0;\t\t\t//学分 \tfloat Ca = 0, Cb = 0;\t\t//学分绩点 \tchar c[5];\tint s;\tfloat result_a, result_b;\tscanf(&quot;%d&quot;, &amp;n);\tfor (int i = 0; i &lt; n; i++) &#123;\t\t//计算Sa、Ca\t\tscanf(&quot;%d&quot;, &amp;s);\t\tscanf(&quot;%s&quot;, c);\t\tif (c[0] != &#x27;P&#x27; &amp;&amp; c[0] != &#x27;N&#x27;) &#123;\t\t//如果是P或者N，就不计入\t\t\tSa += s;\t\t\tint tmp = 0;\t\t\tfor (int j = 0; ; j++) &#123;\t\t//将字符串转换为十进制数字\t\t\t\tif (c[j] == &#x27;\\0&#x27;)\t\t\t\t\tbreak;\t\t\t\ttmp = tmp * 10 + c[j] - 48;\t\t\t&#125;\t\t\tCa += tmp * s;\t\t&#125;\t&#125;\tscanf(&quot;%d&quot;, &amp;n);\t\t//计算Sb、Cb\tfor (int i = 0; i &lt; n; i++) &#123;\t\tscanf(&quot;%d&quot;, &amp;s);\t\tscanf(&quot;%s&quot;, &amp;c[0]);\t\tif (c[0] != &#x27;P&#x27; &amp;&amp; c[0] != &#x27;N&#x27;) &#123;\t\t\tSb += s;\t\t\tint tmp = 0;\t\t\tfor (int j = 0; ; j++) &#123;\t\t\t\tif (c[j] == &#x27;\\0&#x27;)\t\t\t\t\tbreak;\t\t\t\ttmp = tmp * 10 + c[j] - 48;\t\t\t&#125;\t\t\tCb += tmp * s;\t\t&#125;\t&#125;\tresult_a = Ca / Sa;\t\t//printf输出的时候默认四舍五入\tresult_b = Cb / Sb;\tif (result_a - result_b &lt;= 0.01 &amp;&amp; result_a - result_b &gt;= -0.01)\t//这里必须这样写，否则一个测试用例过不了，无须在意这里\t\tprintf(&quot;0.00&quot;);\telse\t\tprintf(&quot;%.2f&quot;, result_a - result_b);\treturn 0;&#125;\n\n凯撒密码题目在密码学中，恺撒密码（Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后循环按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n输入格式:一个字符串（仅仅一行,字符不超过1000）。\n输出格式:加密的字符串。注：字符串中大写字母循环后移3位，小写字母循环后移3位，其它符号不变。\n输入样例:abc xyz!\n\n输出样例:def abc!\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;    char a[1001];    gets(a);    int n;    n = strlen(a);    for (int i = 0; i &lt; n; i++)    &#123;        if ((&#x27;A&#x27; &lt;= a[i] &amp;&amp; a[i] &lt;= &#x27;W&#x27;) || (&#x27;a&#x27; &lt;= a[i] &amp;&amp; a[i]&lt;=&#x27;w&#x27;))        &#123;            printf(&quot;%c&quot;, a[i] + 3);        &#125;        else        &#123;            if ((&#x27;W&#x27; &lt; a[i] &amp;&amp; a[i] &lt;= &#x27;Z&#x27;) || (&#x27;w&#x27; &lt; a[i] &amp;&amp; a[i]&lt;=&#x27;z&#x27;))            &#123;                printf(&quot;%c&quot;, a[i] - 23);            &#125;            else            &#123;                printf(&quot;%c&quot;, a[i]);            &#125;        &#125;    &#125;    return 0;&#125;\n\n打dotaⅡ题目在DOTA2中，乞求者卡尔可以召唤三种元素，冰(Quas)，雷(Wex)，火(Exort)，当你按下Q时，他会召唤一个冰元素，按下W召唤雷元素，按下E召唤火元素。所有元素总数量最大为3，这意味着当你已经拥有了3个任意元素时，若你再召唤一个元素，则最先召唤出的元素会消失，新元素诞生。与此同时，他还有一个技能-元素祈唤(R)。元素祈唤可以根据你当前拥有的各类元素数量施放不同的技能，施放技能后，元素并不会消失，当元素数量不足三个的时候不能施放出技能。更详细解释请看样例说明。请你根据卡尔的操作，打印出他放了什么技能,若不能施放出技能，则输出” FFFFFFFK”。技能列表如下图所示：\n\n输入格式:一个只包含QWER的字符串，且长度不超过10^6。\n输出格式:每次卡尔按下R，就输出一个答案，每个答案占一行。\n输入样例:EERERWRWRWRR\n\n输出样例:FFFFFFFKSun StrikeChaos MeteorAlacrityEMPEMP\n\n###提示：状态没有顺序，比如WEE和EWE和EEW是相同的\n在第一次使用R时，卡尔的状态为EE，并不能用出技能。\n在第二次使用R时，卡尔的状态为EEE，能够使用Sun Strike\n在第三次使用R时，卡尔的状态为EEW，能够使用Chaos Meteor\n在第四次使用R时，卡尔的状态为EWW，能够使用Alacrity\n在第五次使用R时，卡尔的状态为WWW,能够使用EMP\n在第六次使用R时，卡尔的状态为WWW,能够使用EMP\n题解分析代码#include&lt;stdio.h&gt;#include &lt;string.h&gt;void dotall(char* c);int main()&#123;    char a[1000005];    char b[4] = &#123; &#x27;\\0&#x27;&#125;;    int i, n, j = 0;    scanf(&quot;%s&quot;, a);    n = strlen(a);    for (i = 0; i &lt; n; i++)    &#123;        if (a[i] == &#x27;R&#x27;)        &#123;            dotall(b);        &#125;        else        &#123;            if (j &lt; 3)            &#123;                b[j] = a[i];                j++;            &#125;            else            &#123;                b[0] = b[1];                b[1] = b[2];                b[2] = a[i];            &#125;        &#125;    &#125;    return 0;&#125;void dotall(char* c)&#123;    if (strlen(c) &lt; 3)        printf(&quot;FFFFFFFK\\n&quot;);    else    &#123;        if (strcmp(c, &quot;WWW&quot;) == 0)            printf(&quot;EMP\\n&quot;);        else if (strcmp(c, &quot;QQQ&quot;) == 0)            printf(&quot;Cold Snap\\n&quot;);        else if (strcmp(c, &quot;EEE&quot;) == 0)            printf(&quot;Sun Strike\\n&quot;);        else if (strcmp(c, &quot;QWW&quot;) == 0 || strcmp(c, &quot;WWQ&quot;) == 0 || strcmp(c, &quot;WQW&quot;) == 0)            printf(&quot;Tornado\\n&quot;);        else if (strcmp(c, &quot;WWE&quot;) == 0 || strcmp(c, &quot;EWW&quot;) == 0 || strcmp(c, &quot;WEW&quot;) == 0)            printf(&quot;Alacrity\\n&quot;);        else if (strcmp(c, &quot;QQE&quot;) == 0 || strcmp(c, &quot;QEQ&quot;) == 0 || strcmp(c, &quot;EQQ&quot;) == 0)            printf(&quot;Ice Wall\\n&quot;);        else if (strcmp(c, &quot;QEE&quot;) == 0 || strcmp(c, &quot;EQE&quot;) == 0 || strcmp(c, &quot;EEQ&quot;) == 0)            printf(&quot;Forge Spirit\\n&quot;);        else if (strcmp(c, &quot;WEE&quot;) == 0 || strcmp(c, &quot;EWE&quot;) == 0 || strcmp(c, &quot;EEW&quot;) == 0)            printf(&quot;Chaos Meteor\\n&quot;);        else if (strcmp(c, &quot;QQW&quot;) == 0 || strcmp(c, &quot;QWQ&quot;) == 0 || strcmp(c, &quot;WQQ&quot;) == 0)            printf(&quot;Ghost Walk\\n&quot;);        else            printf(&quot;Deafening Blast\\n&quot;);    &#125;&#125;\n\n题目集53的倍数题目给你一个正整数，请你判断它是不是3的倍数？\n输入格式:输入数据有一个T(T&lt;&#x3D;50)，代表有T组数据\n对于每组数据，一个整数n (1&lt;&#x3D;n&lt;&#x3D;101000) 注意数据范围\n这个题需要知道一个数能被3整除的特殊性质，即每一位数字的和能够被3整除，该数字就能被3整除。\n输出格式:对于每组数据，输出一行“YES”或“NO”（不包括引号），代表这个数是或不是3的倍数\n输入样例:在这里给出一组输入。例如：\n233332123\n\n输出样例:在这里给出相应的输出。例如：\nNOYES\n\n题解分析代码#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;\tint n, b, c = 0;\tscanf(&quot;%d&quot;, &amp;n);\tchar a[99999];\tfor (int i = 1; i &lt;= n; i++, c = 0)\t&#123;\t\tscanf(&quot;%s&quot;, a);\t\tb = strlen(a);\t\tfor (int j = 0; j &lt; b; j++)\t\t&#123;\t\t\tc = c + (a[j] % 48);\t\t&#125;\t\tif (c % 3 == 0)\t\t&#123;\t\t\tprintf(&quot;YES\\n&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;NO\\n&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n插座问题题目体育馆内要举办一场程序设计竞赛的现场赛，需要接入服务器、路由器、打印机、电脑等电子设备（假定所有用电器的插头都是三头的）。而体育馆内的墙上只有一个三孔插座可供使用。现在组委会需要购买一批插排（插头为三头，所有插孔都为三孔），使得全部用电器都能通电。想让你帮忙算算至少需要购买多少插排？\n输入格式:输入两个整数N,K，分别表示N个用电器以及每个插排都有K个插口（1&lt;&#x3D;N&lt;&#x3D;100，2&#x3D;&lt;K&lt;&#x3D;100）\n输出格式:一个数，表示所需最少的插排数量。\n输入样例:在这里给出一组输入。例如：\n10 4\n\n输出样例:在这里给出相应的输出。例如：\n3\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int N, K;    scanf(&quot;%d%d&quot;, &amp;N, &amp;K);    int m, n;    m = (N - 1) % (K - 1);    n = (N - 1) / (K - 1);    if (m == 0)        printf(&quot;%d&quot;, n);    else        printf(&quot;%d&quot;, n + 1);    return 0;&#125;\n\n简单计算器题目模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。\n输入格式:输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”&#x3D;”说明输入结束。\n输出格式:在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。\n输入样例:1+2*10-10/2=\n\n输出样例:10\n\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;\tint num_1, num_2, flag = 0;\tchar operator;\tscanf(&quot;%d&quot;, &amp;num_1);\twhile (1)\t&#123;\t\tscanf(&quot;%c&quot;, &amp;operator);\t\t//判断是否为 =\t\tif (operator != &#x27;=&#x27;)//不是 = 的情况\t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;num_2);\t\t\t\t\t\tif (operator == &#x27;+&#x27;)\t\t\t&#123;\t\t\t\tnum_1 = num_1 + num_2;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (operator == &#x27;-&#x27;)\t\t\t\t&#123;\t\t\t\t\tnum_1 = num_1 - num_2;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tif (operator==&#x27;*&#x27;)\t\t\t\t\t&#123;\t\t\t\t\t\tnum_1 = num_1 * num_2;\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\tif (operator == &#x27;/&#x27;)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tif (num_2 != 0)\t\t\t\t\t\t\t&#123;\t\t\t\t\t\t\t\tnum_1 = num_1 / num_2;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\telse\t\t\t\t\t\t\t&#123;\t\t\t\t\t\t\t\tflag = 1;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;\t\t\t\t\t\telse\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tflag = 1;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tif (flag == 1)\t&#123;\t\tprintf(&quot;ERROR&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;%d\\n&quot;, num_1);\t&#125;\treturn 0;&#125;\n\n验证“哥德巴赫猜想”题目数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：24&#x3D;5+19，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。\n输入格式：输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。\n输出格式：在一行中按照格式“N &#x3D; p + q”输出N的素数分解，其中p ≤ q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。\n输入样例：24\n\n输出样例：24 = 5 + 19\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;math.h&gt;int is_prime_num(int n);int main()&#123;\tint num, i, j;\tint (*p)(int) = &amp;is_prime_num;\tscanf(&quot;%d&quot;, &amp;num);\tfor (i = 2; i &lt; num; i++)\t&#123;\t\tj = num - i;\t\tif (p(i) == 1 &amp;&amp; p(j) == 1)\t\t&#123;\t\t\tif (i + j == num)\t\t\t&#123;\t\t\t\tprintf(&quot;%d = %d + %d&quot;, num, i, j);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;int is_prime_num(int n)&#123;\tint i;\tif (n == 2)\t\treturn 1;\tif (n % 2 == 0)\t\treturn 0;\tfor (i = 3; i &lt;= sqrt(n); i += 2)\t\tif (n % i == 0)\t\t\treturn 0;\treturn 1;&#125;\n\n韩信点兵题目在中国数学史上，广泛流传着一个“韩信点兵”的故事：韩信是汉高祖刘邦手下的大将，他英勇善战，智谋超群，为汉朝建立了卓越的功劳。据说韩信的数学水平也非常高超，他在点兵的时候，为了知道有多少兵，同时又能保住军事机密，便让士兵排队报数：\n\n按从1至5报数，记下最末一个士兵报的数为1；\n再按从1至6报数，记下最末一个士兵报的数为5；\n再按从1至7报数，记下最末一个士兵报的数为4；\n最后按从1至11报数，最末一个士兵报的数为10；\n\n请编写程序计算韩信至少有多少兵。\n输入格式：本题无输入\n输出格式：输出韩信至少拥有的士兵人数。\n题解分析代码#include &lt;stdio.h&gt;int main()&#123;    int i;\tfor(i=1;i&gt;0;i++)\t&#123;\t\tif(i%5==1 &amp;&amp; i%6==5 &amp;&amp; i%7==4 &amp;&amp; i%11==10)\t\t&#123;\t\t\tprintf(&quot;%d&quot;,i);\t\t\tbreak;\t\t&#125;\t&#125;    return 0;&#125;\n\n求集合数据的均方差题目\n输入格式：输入首先在第一行给出一个正整数 N（≤104），随后一行给出 N 个正整数。所有数字都不超过 1000，同行数字以空格分隔。\n输出格式：输出这N个数的均方差，要求固定精度输出小数点后5位。\n输入样例 1：106 3 7 1 4 8 2 9 11 5\n\n输出样例 1：3.03974\n\n输入样例 2：12\n\n输出样例 2：0.00000\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;    int n,i,a[10000];    double avage,sum = 0;    scanf(&quot;%d&quot;,&amp;n);    for(i=0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);        sum+=a[i];    &#125;    avage = sum/n;    sum = 0;    for(i=0;i&lt;n;i++)    &#123;        //调用pow函数，求平方        sum += pow(a[i]-avage,2.0);            &#125;    avage = sum/n;    printf(&quot;%.5lf&quot;,sqrt(avage));    return 0;&#125;\n\n考试座位号题目每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。\n输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。\n考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。\n输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。\n输入样例：43310120150912233 2 43310120150912119 4 13310120150912126 1 33310120150912002 3 223 4\n\n输出样例：3310120150912002 23310120150912119 1\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint total_stu_1, total_stu_2, seat_num[1000], test_num[1000],arr[1000];\tlong long int  id[1000];\tscanf(&quot;%d&quot;, &amp;total_stu_1);\tfor (int i = 0; i &lt; total_stu_1; i++)\t&#123;\t\tscanf(&quot;%lld %d %d&quot;, &amp;id[i], &amp;seat_num[i], &amp;test_num[i]);\t&#125;\tscanf(&quot;%d&quot;, &amp;total_stu_2);\tfor (int i = 0; i &lt; total_stu_2; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tfor (int i = 0; i &lt; total_stu_2; i++)\t&#123;\t\tfor (int j = 0; j &lt; total_stu_1; j++)\t\t&#123;\t\t\tif (arr[i] == seat_num[j])\t\t\t&#123;\t\t\t\tprintf(&quot;%lld %d\\n&quot;, id[j], test_num[j]);\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n手机号码题目我国使用的手机号码为11位，其中各段有不同的编码方向：前3位是网络识别号；第4-7位为地区编码；第8-11位表示用户号码。\n本题要求你实现一个程序，自动统计指定地区编码的手机号码的个数。\n输入格式:输入第一行为待查询的地区编码，随后每行都是11位数字组成的手机号码，当读到某一行只有一个英文句点 . 时，输入结束。\n输出格式:首先在第一行中输出手机号码的总个数。然后统计指定地区编码的手机号码有多少个。第二行首先输出第一次出现该地区编码的手机号码是第几个（从 1 开始计数，没有输出0），然后输出该地区编码手机号码的总个数（没有输出0），其间以一个空格分隔。题目保证输出的所有数字不超过109。\n输入样例:054913563910168135054901991885390508913705390115.\n\n输出样例:42 1\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tint target_num, i = 0, count = 0, first_num = 0;\tlong long int phone_num[100000];//来储存电话号码\tscanf(&quot;%d&quot;, &amp;target_num);\twhile (1)\t&#123;\t\tif (scanf(&quot;%lld&quot;, &amp;phone_num[i]))\t\t&#123;\t\t\tphone_num[i] = (phone_num[i] / 10000) % 10000;\t\t\tif (phone_num[i] == target_num)\t\t\t&#123;\t\t\t\tcount++;\t\t\t\tif (count == 1)\t\t\t\t&#123;\t\t\t\t\tfirst_num = i + 1;\t\t\t\t&#125;\t\t\t&#125;\t\t\ti++;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tprintf(&quot;%d\\n%d %d&quot;, i, first_num, count);\treturn 0;&#125;\n\nZZU联盟题目2018年11月3日，万众瞩目的英雄联盟S8世界赛总决赛在韩国仁川开打，8年来第一次同组两支战队在总决赛争夺冠军，IG和FNC的对决引玩家期待。最终S8世界赛冠军诞生！IG3:0击溃FNC拿下胜利！中国LOL拿下世界冠军！\nACM-ICPC实验室的成员得知消息后激动不已，决定自己开发一款游戏——ZZU联盟。小J是负责每场比赛后MVP评选模块设计的，如何根据每个队员在游戏中的表现，评选出当场的MVP难住了他，需要你来帮忙。在真实的LOL游戏中，MVP的评选涉及伤害输出、承受伤害与死亡比、平均每分钟获得金钱、对塔伤害 10%、大小龙及野怪的控制、对敌方的控制时间 2.5%、技能躲闪与命中、多杀、连杀、团队装与团队贡献（团战效率比）、支援效率（参团率）、所用英雄位置与熟练度预期（游戏默认）、KDA（击杀Kill、死亡Death、助攻Assist）等等好多因素。而ZZU联盟在其第一个版本中，决定先不考虑那么复杂，采用的评选指标如下：\n（1）伤害输出值 Dps （0 &#x3D;&lt; Dps &lt;&#x3D; 50000）\n（2）累计获得金钱数 M （0 &#x3D;&lt; M &lt;&#x3D; 30000）\n（3）对塔伤害 Tow （0 &#x3D;&lt; Tow &lt;&#x3D; 10000）\n（4）支援率 S (0 &#x3D;&lt; S &lt;&#x3D; 100)\n（5）击杀K、死亡D、助攻A (0 &#x3D;&lt; K, D, A &lt;&#x3D; 30)\n其中，每个值都为整数。\n最终，对于每个选手都有一个MVP候选值（双精度实数）\nV &#x3D; Dps&#x2F;50000 + M &#x2F; 30000 + Tow &#x2F; 10000 + S &#x2F; 100 + (K + A) &#x2F; (D+1）\n而MVP获得者是获胜方中V值最大的玩家，数据保证每场比赛的MVP是唯一的。\n输入格式:第一行一个整数T(1&#x3D;&lt;T&lt;&#x3D;200)，表示接下来共有T组测试数据\n对于每组测试数据来说，\n第一行, win&#x2F;lose，表示蓝色军团获胜&#x2F;失败接下来5行，分别为5名玩家的赛后指标统计值，其中每一行的格式都为\n玩家ID Dps M Tow S K D A（玩家ID字符长度不超过20，所有内容全用空格隔开）\n紧接着一行为win&#x2F;lose，表示紫色军团获胜&#x2F;失败\n接下来5行同样为紫色军团中5名玩家的战绩，格式同样为\n玩家ID Dps M Tow S K D A\n输出格式:T行，对于每组测试数据，输出该场比赛Mvp选手的玩家ID\n输入样例:2winzxy 23197 13453 8636 61 6 3 3fxr 12155 9854 8769 57 2 4 10sgl 21232 23717 5215 67 24 23 25cy 8268 201 3151 21 0 27 8lzh 22306 15051 6246 54 22 28 5losechj 16800 14340 4185 90 19 20 23cwc 2646 1759 6548 60 0 7 5wjk 11467 951 9615 52 4 16 11lmc 29038 11256 173 64 8 3 3lx 4686 11291 2677 77 16 26 22loselzl 7670 14713 4174 42 6 23 7gy 13955 5514 5087 91 15 29 4sq 253 4773 7454 13 9 6 1gxb 32055 7682 6093 83 16 7 26gxh 24687 12611 3652 70 10 25 29winzyj 5074 12640 1414 64 29 8 6hzy 23484 20429 6293 54 22 16 2hzp 14823 20893 448 58 9 9 10sjf 13059 6451 2344 72 5 13 17tjt 26347 13267 5171 46 6 23 15\n\n输出样例:zxyzyj\n\n题解分析代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tint T, Dps, M, Tow, S, K, D, A, count = 0;\tchar result_game[2][5], ID[5][21], mvp[200][21];\tdouble V = 0, max = 0;\tscanf(&quot;%d&quot;, &amp;T);\tfor (count = 0; count &lt; T; count++)\t&#123;\t\tfor (int j = 0; j &lt; 2; j++)\t\t&#123;\t\t\tscanf(&quot;%s&quot;, result_game[j]);\t\t\tif (result_game[j][0] == &#x27;w&#x27;)\t\t\t&#123;\t\t\t\tfor (int m = 0; m &lt; 5; m++)\t\t\t\t&#123;\t\t\t\t\tscanf(&quot;%s %d %d %d %d %d %d %d&quot;, ID[m], &amp;Dps, &amp;M, &amp;Tow, &amp;S, &amp;K, &amp;D, &amp;A);\t\t\t\t\tV = Dps / 50000.0 + M / 30000.0 + Tow / 10000.0 + S / 100.0 + (K + A) / ((D + 1) * 1.0);\t\t\t\t\tif (V &gt; max)\t\t\t\t\t&#123;\t\t\t\t\t\tmax = V;\t\t\t\t\t\tstrcpy(mvp[count], ID[m]);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tfor (int n = 0; n &lt; 5; n++)\t\t\t\t&#123;\t\t\t\t\tscanf(&quot;%s %d %d %d %d %d %d %d&quot;, ID[n], &amp;Dps, &amp;M, &amp;Tow, &amp;S, &amp;K, &amp;D, &amp;A);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tfor (int i = 0; i &lt; count; i++)\t&#123;\t\tprintf(&quot;%s\\n&quot;, mvp[i]);\t&#125;\treturn 0;&#125;\n\n数字液晶屏幕题目LED屏的液晶显示在工业上有着十分重要的应用，\n\n现在W老师给你个任务，给你一个仅包含数字的字符串，输出其液晶显示效果。本题中，我们利用’-‘和’|’表示液晶数字中的笔画，可以看出每个数字对应的液晶显示格式都严格占据5行3列的空间（空格也需要输出），例如数字8：\n\n因此，数字0-9可以表示为：\n\n输入格式:一行，仅包含数字的字符串（字符串长度不超过200）\n输出格式:该数字对应的液晶显示效果\n输入样例:0123456789\n\n输出样例:\n\n题解分析代码# include&lt;stdio.h&gt;# include&lt;string.h&gt;int main()&#123;\tchar ch[500];\tint m, n, i, j;\tgets(ch);\tm = strlen(ch);\tfor (n = 0; n &lt; 5; n++)\t&#123;\t\tif (n == 0)\t\t&#123;\t\t\tfor (i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tif (ch[i] == &#x27;0&#x27; || ch[i] == &#x27;2&#x27; || ch[i] == &#x27;3&#x27; || ch[i] == &#x27;5&#x27; || ch[i] == &#x27;6&#x27; || ch[i] == &#x27;7&#x27; || ch[i] == &#x27;8&#x27; || ch[i] == &#x27;9&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; - &quot;);\t\t\t\t&#125;\t\t\t\tif (ch[i] == &#x27;1&#x27; || ch[i] == &#x27;4&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;   &quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t\tif (n == 1)\t\t&#123;\t\t\tfor (i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tif (ch[i] == &#x27;0&#x27; || ch[i] == &#x27;4&#x27; || ch[i] == &#x27;8&#x27; | ch[i] == &#x27;9&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;| |&quot;);\t\t\t\t&#125;\t\t\t\tif (ch[i] == &#x27;1&#x27; || ch[i] == &#x27;2&#x27; || ch[i] == &#x27;3&#x27; || ch[i] == &#x27;7&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;  |&quot;);\t\t\t\t&#125;\t\t\t\tif (ch[i] == &#x27;5&#x27; || ch[i] == &#x27;6&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;|  &quot;);\t\t\t\t&#125;\t\t\t&#125;printf(&quot;\\n&quot;);\t\t&#125;\t\tif (n == 2)\t\t&#123;\t\t\tfor (i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tif (ch[i] == &#x27;0&#x27; || ch[i] == &#x27;1&#x27; || ch[i] == &#x27;7&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;   &quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; - &quot;);\t\t\t\t&#125;\t\t\t&#125;printf(&quot;\\n&quot;);\t\t&#125;\t\tif (n == 3)\t\t&#123;\t\t\tfor (i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tif (ch[i] == &#x27;0&#x27; || ch[i] == &#x27;6&#x27; || ch[i] == &#x27;8&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;| |&quot;);\t\t\t\t&#125;\t\t\t\tif (ch[i] == &#x27;1&#x27; || ch[i] == &#x27;3&#x27; || ch[i] == &#x27;4&#x27; || ch[i] == &#x27;5&#x27; || ch[i] == &#x27;7&#x27; || ch[i] == &#x27;9&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;  |&quot;);\t\t\t\t&#125;\t\t\t\tif (ch[i] == &#x27;2&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;|  &quot;);\t\t\t\t&#125;\t\t\t&#125;printf(&quot;\\n&quot;);\t\t&#125;\t\tif (n == 4)\t\t&#123;\t\t\tfor (i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tif (ch[i] == &#x27;1&#x27; || ch[i] == &#x27;4&#x27; || ch[i] == &#x27;7&#x27;)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;   &quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; - &quot;);\t\t\t\t&#125;\t\t\t&#125;printf(&quot;\\n&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n最大公约数和最小公倍数题目本题要求两个给定正整数的最大公约数和最小公倍数。\n输入格式:输入在一行中给出两个正整数M和N（≤1000）。\n输出格式:在一行中顺序输出M和N的最大公约数和最小公倍数，两数字间以1空格分隔。\n输入样例:511 292\n\n输出样例:73 2044\n\n题解分析代码#include &lt;stdio.h&gt;int main() &#123;    int a, b, m, n, c;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    c = a * b;//最小公倍数    while (a &amp;&amp; b)     &#123;        if (a &gt; b)             a %= b;        else             b %= a;    &#125;    m = a &gt; b ? a : b;    printf(&quot;%d %d&quot;, m,c / m);&#125;\n\n兔子繁衍问题题目一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。假如兔子都不死，请问第1个月出生的一对兔子，至少需要繁衍到第几个月时兔子总数才可以达到N对？\n输入格式:输入在一行中给出一个不超过10000的正整数N。\n输出格式:在一行中输出兔子总数达到N最少需要的月数。\n输入样例:30\n\n输出样例:9\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;    int a=1,b=1,s=2,n,m=3;    scanf(&quot;%d&quot;,&amp;n);    if(n==1)printf(&quot;1&quot;);    else     &#123;        while(s&lt;n)        &#123;            m++;            a=b;            b=s;            s=s+a;        &#125;        printf(&quot;%d&quot;,m);    &#125;return 0;&#125;\n\n统计字母个数题目输入一串以“@”为结束标记的字符序列，请统计出其中字母的个数。\n输入格式:输入一串以“@”为结束标记的字符序列\n输出格式:输出字母的个数。\n输入样例:The moon is 384000 kilometers from the earth@\n\n输出样例:31\n\n题解分析代码# include&lt;stdio.h&gt;int main()&#123;\tchar ch;\tint i,j,count=0;\twhile((ch=getchar())!=&#x27;\\n&#x27;)\t&#123;\t\tif((ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;)||(ch&gt;=&#x27;A&#x27;&amp;&amp;ch&lt;=&#x27;Z&#x27;))\t\t&#123;\t\t\tcount++;\t\t&#125;\t&#125;\tprintf(&quot;%d\\n&quot;,count);\treturn 0;&#125;\n\n统计英语单词个数题目英语王老师正在开发一个英语作文线上系统，需要自动计算文中的单词个数。在最初的版本中，王老师并不打算加入拼写错误检查。因此，连续的英文字母都被认为是一个“单词”，单词之间使用空格或标点符号区分。请你设计一个程序，统计一行英文输入中的单词个数。为了简便算法，已提前去除了文本中的标点符号。因此，输入的文本中只包含单词和空格。\n输入格式:输入一行带有空格的字符（不超过 1000 个字符），以换行符结尾。保证输入的字符中仅包含英文字母（包含大写字母和小写字母）和空格。\n输出格式:输出这行英文字符中单词的个数。\n输入样例1:I love Ningbo\n\n输出样例1:3\n\n输入样例2:All C programs do the same thing look at a character and do nothing with it\n\n输出样例2:16\n\n题解分析代码#include&lt;stdio.h&gt;int main()&#123;\tchar str[1001]; \tint count=0,i,flag=0;\tgets(str);  //用gets()函数可以把空格输入; \t\tfor( i = 0 ; str[i] ; i++)\t&#123;\t\tif ( str[i] == 32) //空格的值为32; \t\t&#123;\t\t\tflag = 0; //标记此处的单词为0; \t\t&#125;\t\telse if( flag == 0)\t\t&#123;\t\t\tcount++;\t\t\tflag = 1; //统计数量并覆盖此处的单词; \t\t&#125; \t&#125;\tprintf(&quot;%d&quot;,count);  //输出结果; \treturn 0;&#125;","categories":["PTA","C"],"tags":["C语言","PTA"]},{"title":"free函数删除链表节点报错问题","url":"/2022/08/09/free%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","content":"写程序时遇到的一个bug\n\n\n今天在写链表指定删除的时候，程序一旦运行会崩溃，cmd.exe还关闭不了，只有等重启之后才能关闭。\n最后调试才发现一旦运行到free函数就会崩溃，非常的懵逼。\nfree()的调用方式是：void  free(void  *ptr),释放由ptr所指的内存，并将它返回给堆，以便这些内存成为再分配时的可用内存。但是free()函数并不能将指针ptr赋空。\n所以，对于对于用malloc分配空间的指针p, 使用过后要这样释放：\n\nfree(p);\np&#x3D;NULL;\n\n在我找了一段时间后发现的问题所在内存溢出或者说内存分配出现了问题\n下面是我的代码的一部分：\n// 创建表头struct Node*creatHead()&#123;\t// 动态内存申请\tstruct Node* headnode = (struct Node*)malloc(sizeof(struct Node*)); \theadnode-&gt;next = NULL;\treturn headnode;&#125;;// 创建节点struct Node* creatNode(int data)&#123;\tstruct Node* newNode = (struct Node*)malloc(sizeof(struct Node*));\tnewNode-&gt;data = data;\tnewNode-&gt;next = NULL;\treturn newNode;&#125;\n\n// 指定数据删除void deleteNodeByData(struct Node* Nodehead, int posdata)&#123;\tstruct Node* posleftNode = Nodehead;\tstruct Node* posNode = Nodehead-&gt;next;\t//查找删除节点\twhile (posNode != NULL &amp;&amp; posNode-&gt;data != posdata)\t&#123;\t\tposleftNode = posNode;\t\tposNode = posleftNode-&gt;next;\t&#125;\t//判断查找结果\tif (posNode == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tposleftNode-&gt;next = posNode-&gt;next;\t\tfree(posNode);\t\tposNode = NULL;\t&#125;&#125;\n\n上面代码的问题就出现在创建动态链表的时候malloc(sizeof(struct Node*))出现了问题\n\nsizeof(struct Node)  &#x3D; 16\nsizeof(struct Node*) &#x3D; 8\n\n在这个程序中，每次我们分配一个8字节的大小给节点，但在下面赋值的时候有超过了8字节，当我们free的时候，给free函数一个指针，但是在内存中已经乱了，不是我们想要的地址了，那个时候我们free掉的不是我们想要free的节点，而是不知道什么东西让我们free了，这个时候程序就崩溃了。\n","categories":["笔记","C"],"tags":["C语言","编译器报错"]},{"title":"文件读写函数","url":"/2022/07/16/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0/","content":"C语言中关于文件读写的函数\n\n\n字符读写字符写入文件函数 fputcfputc函数的原型如下：\nint fputc( int c, FILE *fp );\n\n参数说明：    其中，c是要写入的字节，它虽被定义为整型，但只使用最低位的一字节，fp是文件指针。\nfputc的功能:    将字节c输出至fp所指向的文件。如果成功，位置指针自动后 移1字节的位置，并且返回c；否则返回EOF。\n从文件中读取字符 fgetcfgetc函数的原型如下:\nint fgetc( FILE *fp );\n\n参数说明：    其中fp为文件指针。\nfgetc的功能:    从fp所指向的文件中读取一个字节，如果成功则返回读取的字节，位置指针自动后移1字节的位置；否则返回EOF。\n字符串的读写字符串写入文件函数 fputsfputs函数的原型如下：\nint fputs( const char *s, FILE *fp );\n\n参数说明：    其中，s是要写入的字符串，fp是文件指针。\nfputs的功能：    将字符串s输出至fp所指向的文件（不含’\\0’）。如果成功，位置指针自动后移，函数返回一个非负整数；否则返回EOF。\n从文件中读取字符 fgetsfgets函数的原型如下：\nchar *fgets( char *s， int n， FILE *fp );\n\n参数说明：    其中，s指向待赋值字符串的首地址，n是控制读取个数的参数，fp为文件指针。 \nfgets的功能：    从位置指针开始读取 一行或n-1个字符，并存入s，存储时自动在字符串结尾加上’\\0’。如果函数执行成功，位置指针自动后移，并返回s的值，否则返回NULL。\n块数据读写所谓块读写，就是读写n块以m个字节为单位的二进制数据，可以是一个字符（一个字符为一字节，则块大小为1×1),可以是一个长度为n字符串（块大小1×n），可以是长度为n的整型数组（整型以4字节算，块大小4×n），也可以是结构体等任意数据类型，并没有什么限制。\n向文件中写入块数据fwritefwrite函数的原型如下：\nsize_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );\n\n参数说明：    ptr：指向保存读写数据的内存的指针，它可以指向数组、变量、结构体等。    size：表示每个数据块的字节数。    count：表示要读写的数据块的块数。    fp：表示文件指针。    理论上，每次读写 size*count 个字节的数据。\nfwrite的功能：    从内存中的ptr指向的地址开始，将连续n*size字节的内容写入fp文件中。该函数的返回值是实际写入的数据块个数。\n从文件中读取块数据freadfread函数的原型如下：\nsize_t fread ( void *ptr, size_t size, size_t count, FILE *fp );\n&#x2F;&#x2F;size_t 是在 stddef.h 头文件中使用 typedef 定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。\n参数说明：    见[[文件读写函数#^ece6a5|fwrite]]\nfread的功能：    从文件fp中，连续读取n*size字节的内容，并存入ptr指向的内存空间。该函数的返回值是实际读入的数据块个数。\n格式化读写格式化读写函数包括fprintf和fscanf两个函数，它们只用于文本文件的读写，不能用于二进制文件的读写。文本文件与二进制文件的区别下面注意点中有介绍。\n格式化写入文件fprintffprintf函数的原型如下：\nint fprintf( FILE *fp, const char* format, 输出参数1, 输出参数2… );\n\n参数说明:    其中，fp是文件指针，format为格式控制字符串，输出参数列表为待输出的数据。 \nfprintf的功能：    根据指定的格式（format参数）发送数据（输出参数）到文件fp。例：\n#include &lt;stdio.h&gt;int main()&#123;    FILE *fp;    fp = fopen(&quot;a.txt&quot;,&quot;w&quot;);    int a = 10;    double f = 11.11;    fprintf(fp, &quot;%d%lf&quot;, a, f);    fclose(fp);    return 0;&#125;\n\n注意：fprintf()按格式输入到流，其用法和printf()相同，不过不是写到控制台，而是写到流罢了。注意的是返回值为此次操作写入到文件的字节数。如int c &#x3D;fprintf(fp, “%s %s %d %f”, str1,str2, a, b) ;假设str1：10字节；str2：10字节；a：2字节；b：8字节；则最终c为33，因为写入时不同的数据间自动加入一个空格。\n从文件中格式化读取fscanffscanf函数的原型如下：\nint fscanf( FILE *fp,  const char* format, 地址1，地址2… );\n\n函数说明：    其中，fp是文件指针，format为格式控制字符串，地址列表为输入数据的存放地址。 \nfscanf的功能：    根据指定的格式（format参数）从文件fp中读取数据至内存（地址）。例：\n#include &lt;stdio.h&gt;  int main()&#123;    FILE *fp;       fp = fopen(&quot;a.txt&quot;,&quot;r&quot;); //需要创建a.txt文件，然后写入两个数据，空格隔开    int i=0;    double f=0;    fscanf( fp, &quot;%d%lf&quot;, &amp;i, &amp;f );    fclose(fp);    printf(&quot;%d\\n%lf\\n&quot;,i,f);    return 0;&#125;\n\n","categories":["笔记","C"],"tags":["C语言"]},{"title":"图书馆管理系统","url":"/2022/08/10/%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"大一C语言写的大作业\n\n\n初代\n使用的IDE：Visual Studio 2022\n\n这是刚写完就发出来了，所以注释、代码命名等都不是太好\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;// 书籍信息struct bookInfo&#123;\tchar name[20]; // 书名\tfloat price; // 价格\tint num; // 书的数量&#125;;struct Node&#123;\tstruct bookInfo data;\tstruct Node* next;&#125;;// 全局变量struct Node* list;// 创建表头struct Node*creatHead()&#123;\t// 动态内存申请\tstruct Node* headnode = (struct Node*)malloc(sizeof(struct Node)); \theadnode-&gt;next = NULL;\treturn headnode;&#125;;// 创建节点struct Node* creatNode(struct bookInfo data)&#123;\tstruct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\tnewNode-&gt;data = data;\tnewNode-&gt;next = NULL;\treturn newNode;&#125;// 打印链表void printList(struct Node* headNode)&#123;\tstruct Node* Pmove = headNode-&gt;next;\tprintf(&quot;书名\\t价格\\t数量\\n&quot;);\twhile (Pmove != NULL)\t&#123;\t\tprintf(&quot;%s\\t%.1f\\t%d\\n&quot;, Pmove-&gt;data.name, Pmove-&gt;data.price, Pmove-&gt;data.num);\t\tPmove = Pmove-&gt;next;\t&#125;&#125;// 表头法插入void insertNodeByHead(struct Node* headNode, struct bookInfo data)&#123;\tstruct Node* newNode = creatNode(data);\tnewNode-&gt;next = headNode-&gt;next;\theadNode-&gt;next = newNode;&#125;//指定位置删除void deleteNodeByData(struct Node* Nodehead, char* bookname)&#123;\tstruct Node* posleftNode = Nodehead;\tstruct Node* posNode = Nodehead-&gt;next;\t//查找删除节点\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.name,bookname))\t&#123;\t\tposleftNode = posNode;\t\tposNode = posleftNode-&gt;next;\t&#125;\t//判断查找结果\tif (posNode == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tposleftNode-&gt;next = posNode-&gt;next;\t\tfree(posNode);\t\tposNode = NULL;\t&#125;&#125;// 指定查找struct Node* searchByName(struct Node* headNode, char* bookName)&#123;\tstruct Node* posNode = headNode-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.name,bookName))\t&#123;\t\tposNode = posNode-&gt;next;\t&#125;\treturn posNode;&#125;// 写菜单void makeMenu()&#123;\tprintf(&quot;-------------------\\n&quot;);\tprintf(&quot;图书管理系统\\n&quot;);\tprintf(&quot;\\t0.退出系统\\n&quot;);\tprintf(&quot;\\t1.登记书籍\\n&quot;);\tprintf(&quot;\\t2.浏览书籍\\n&quot;);\tprintf(&quot;\\t3.借阅书籍\\n&quot;);\tprintf(&quot;\\t4.归还书籍\\n&quot;);\tprintf(&quot;\\t5.书籍排序\\n&quot;);\tprintf(&quot;\\t6.删除书籍\\n&quot;);\tprintf(&quot;\\t7.查找书籍\\n&quot;);\tprintf(&quot;-------------------\\n&quot;);\tprintf(&quot;请输入0-7:&quot;);&#125;// 文件操作// 存操作void saveInfoToFile(const char* filename, struct Node* headNode)&#123;\tFILE* fp = fopen(filename, &quot;w&quot;);\tstruct Node* Pmove = headNode-&gt;next;\twhile (Pmove != NULL)\t&#123;\t\tfprintf(fp, &quot;%s\\t%.1lf\\t%d\\n&quot;, Pmove-&gt;data.name, Pmove-&gt;data.price, Pmove-&gt;data.num);\t\tPmove = Pmove-&gt;next;\t&#125;\tfclose(fp);&#125;// 写操作void readInfoFromFile(const char* filename, struct Node* headNode)&#123;\tFILE* fp = fopen(filename, &quot;r&quot;);\tif (fp == NULL) // 第一次打开时的情况\t&#123;\t\tfp = fopen(filename, &quot;w+&quot;);\t&#125;\tstruct bookInfo tempData;\twhile (fscanf(fp,&quot;%s\\t%f\\t%d\\n&quot;,tempData.name,&amp;tempData.price,&amp;tempData.num) != EOF)\t&#123;\t\tinsertNodeByHead(list, tempData);\t&#125;\tfclose(fp);&#125;//对链表进行排序void bubble_sort(struct Node* headNode)//冒泡降序排序&#123;\tfor (struct Node* p = headNode-&gt;next; p != NULL; p = p-&gt;next)\t&#123;\t\tfor (struct Node* q = headNode-&gt;next; q-&gt;next != NULL; q = q-&gt;next)\t\t&#123;\t\t\tif (q-&gt;data.price &lt; q-&gt;next-&gt;data.price)\t\t\t&#123;\t\t\t\tstruct bookInfo tempdata = q-&gt;data;\t\t\t\tq-&gt;data = q-&gt;next-&gt;data;\t\t\t\tq-&gt;next-&gt;data = tempdata;\t\t\t&#125;\t\t&#125;\t&#125;&#125;// 写交互void keyDown()&#123; \tint userKey = 0;\tstruct bookInfo tempBook; // 临时用来存储信息\tstruct Node* result;\tscanf(&quot;%d&quot;, &amp;userKey);\tswitch (userKey)\t&#123;\tcase 0:\t\tprintf(&quot;退出\\n&quot;);\t\tprintf(&quot;退出成功\\n&quot;);\t\tsystem(&quot;pause&quot;);\t\texit(0); // 关闭整个程序\t\tbreak;\tcase 1:\t\tprintf(&quot;登记\\n&quot;);\t\tprintf(&quot;请输入书籍的信息:name price num\\n&quot;);\t\tscanf(&quot;%s%f%d&quot;, tempBook.name, &amp;tempBook.price, &amp;tempBook.num);\t\tinsertNodeByHead(list, tempBook);\t\tsaveInfoToFile(&quot;bookInfo.txt&quot;, list); \t\tbreak;\tcase 2:\t\tprintf(&quot;浏览\\n&quot;);\t\tprintList(list);\t\tbreak;\tcase 3:\t\tprintf(&quot;借阅\\n&quot;);\t\tprintf(&quot;请输入你想要借阅的书籍名:&quot;);\t\tscanf(&quot;%s&quot;, tempBook.name);\t\tresult = searchByName(list, tempBook.name);\t\tif (result == NULL)\t\t&#123;\t\t\tprintf(&quot;没有相关书籍&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tif (result-&gt;data.num &gt; 0)\t\t\t&#123;\t\t\t\tresult-&gt;data.num--;\t\t\t\tprintf(&quot;借阅成功\\n&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;当前书籍已被全部借出\\n&quot;);\t\t\t\tprintf(&quot;借阅失败\\n&quot;);\t\t\t&#125;\t\t&#125;\t\tbreak;\tcase 4:\t\tprintf(&quot;归还\\n&quot;);\t\tprintf(&quot;请输入你想要归还的书籍名:&quot;);\t\tscanf(&quot;%s&quot;, tempBook.name);\t\tresult = searchByName(list, tempBook.name);\t\tif (result == NULL)\t\t&#123;\t\t\tprintf(&quot;该书来源非法\\n&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tresult-&gt;data.num++;\t\t\tprintf(&quot;归还成功\\n&quot;);\t\t&#125;\t\tbreak;\tcase 5:\t\tprintf(&quot;排序\\n&quot;);\t\tbubble_sort(list);\t\tprintList(list); // 排序完成后打印一下\t\tbreak;\tcase 6:\t\tprintf(&quot;删除\\n&quot;);\t\tprintf(&quot;请输入删除书名:&quot;);\t\tscanf(&quot;%s&quot;, tempBook.name);\t\tdeleteNodeByData(list, tempBook.name);\t\tsaveInfoToFile(&quot;bookInfo.txt&quot;, list);\t\tprintf(&quot;删除成功&quot;);\t\tbreak;\tcase 7:\t\tprintf(&quot;查找\\n&quot;);\t\tprintf(&quot;请输入要查找的书名:&quot;);\t\tscanf(&quot;%s&quot;, tempBook.name);\t\tresult = searchByName(list, tempBook.name);\t\tif (result == NULL)\t\t&#123;\t\t\tprintf(&quot;未找到书籍信息&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;书名\\t价格\\t数量\\n&quot;);\t\t\tprintf(&quot;%s\\t%.1f\\t%d\\n&quot;, result-&gt;data.name, result-&gt;data.price, result-&gt;data.num);\t\t&#125;\t\tbreak;\tdefault:\t\tprintf(&quot;error\\n&quot;);\t\tbreak;\t&#125;&#125;int main()&#123;\tlist = creatHead();\treadInfoFromFile(&quot;bookInfo.txt&quot;, list);\twhile (1)\t&#123;\t\tmakeMenu();\t\tkeyDown();\t\tsystem(&quot;pause&quot;);\t\tsystem(&quot;cls&quot;);\t&#125;\tsystem(&quot;pause&quot;);&#125;\n\n","tags":["C语言"]},{"title":"汉诺塔问题","url":"/2022/07/18/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/","content":"使用递归解决汉诺塔问题\n\n\n\n\n题目给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。\n输入格式:输入由四行：第一行是圆盘数量n(1&lt;&#x3D;n&lt;&#x3D;10);第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。\n输出格式:输出移动步骤，每行输出一步。\n输入样例:在这里给出一组输入。例如：\n2abc\n\n输出样例:在这里给出相应的输出。例如：\na-&gt;ba-&gt;cb-&gt;c\n\n题解分析过程3个柱子分别命名为起始柱、目标柱和辅助柱。\n\n1个圆盘的情况，直接移过去就行了\n2个圆盘\n\n\n\n\n三个圆盘\n\n\n规律：\n\n将起始柱上的 n-1 个圆盘移动到辅助柱上；\n将起始柱上遗留的 1 个圆盘移动到目标柱上；\n将辅助柱上的所有圆盘移动到目标柱上。\n\n由此，n 个圆盘的汉诺塔问题就简化成了 n-1 个圆盘的汉诺塔问题。按照同样的思路，n-1 个圆盘的汉诺塔问题还可以继续简化，直至简化为移动 3 个甚至更少圆盘的汉诺塔问题。\n代码#include&lt;stdio.h&gt;int count = 1;void hanuota(int n, char* sta, char *aux, char* tar);int main() &#123;\tint n;\tchar sta[20], aux[20], tar[20];\tscanf(&quot;%d %s %s %s&quot;, &amp;n, sta, aux, tar);\thanuota(n, sta, aux, tar);\treturn 0;&#125;void hanuota(int n, char* sta, char* aux, char* tar) &#123;\tif (n == 1) &#123;\t\t//n=1,直接移动到目标柱上 \t\tprintf(&quot;%s-&gt;%s\\n&quot;,sta, tar);\t\tcount++;\t&#125;\telse &#123;\t\thanuota(n - 1, sta, tar, aux);\t\t//将n-1移动到辅助柱上 \t\tprintf(&quot;%s-&gt;%s\\n&quot;,sta, tar);\t\tcount++;\t\thanuota(n - 1, aux, sta, tar);\t&#125;&#125;","categories":["PTA","C"],"tags":["C语言","PTA"]}]