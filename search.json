[{"title":"C语言-图书馆管理系统","url":"/2022/08/10/C%E8%AF%AD%E8%A8%80-%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"大一C语言写的大作业。\n此程序所使用的IDE为 visual studio 2022，所以在其他编译器上运行时可能会出现bug。\n\n\n\n\n程序分析\n图书馆的用户一般分两部分：管理员和学生。所以此图书馆管理系统分为了两部分：管理员端和学生端。运行程序后会让用户选择管理员端、学生端或退出系统。\n\n管理员端\n\n添加新的书籍信息，如书名、作者、书籍的ISBN号、书籍数量、书籍价格信息。如果要登记的书籍已经登记在库的话，会让管理员选择是更新书籍信息还是保留原有的书籍信息。\n查看所有书籍的信息，管理员可以查看书籍的作者、ISBN号以及书籍数量等。\n图书查询，管理员可以通过图书的ISBＮ或者书名进行检索。\n图书删除，管理员可以通过图书的ISBN或者书名对要删除的书籍进行检索，如果要删除的书籍正在借出的话会告诉管理员，此书籍正在借出，目前不能删除此书籍。\n\n\n学生端\n\n图书查询，学生可以通过书名或者书籍的ISBN来查找书籍。\n书籍借阅，学生可以通过书名或者书籍的ISBN来查找要借阅的书籍。\n书籍归还，归还书籍时，学生把输入要归还的书籍的书名即可归还成功。\n对于每个模块，此系统还加上了返回上一级菜单、返回主菜单和退出系统的功能。\n\n\n\n部分功能框架图   总框架：\n   \n   部分框架图：\n   \n程序源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#define IDLength 12 // 学号长度#define MAXNUM 5 // 最多可借阅书籍数struct bookInfo&#123;\tchar name[21+1]; // 书名\tdouble price; // 书的价格\tint current_num; // 书籍当前数量\tint num; // 书籍原有的数量\tchar author[21+1]; // 书的作者\tchar ISBN[13+1]; // 书的ISBN\tint flag; // 判断是否有书被借出&#125;;struct Book&#123;\tstruct bookInfo data;\tstruct Book* next;&#125;;struct studentInfo&#123;\tchar ID[IDLength + 1]; // 学生的学号\tint current_number; // 当前借阅的书籍数\tstruct bookInfo bookinfo[5]; // 最大可借阅书籍数&#125;;struct Student&#123;\tstruct studentInfo student;\tstruct Student* next;&#125;;/*\t下面的是管理员功能所用的函数*/struct Book* creatBookHead();struct Book* creatBook(struct bookInfo data);void insertBookByHead(struct Book* headNode, struct bookInfo data);void printBookList(struct Book* headNode);struct Book* searchBookByName(struct Book* headNode, char* bookname);struct Book* searchBookByISBN(struct Book* headNode, char* bookISBN);void deleteBookByName(struct Book* nodeHead, char* bookName);void deleteBookByISBN(struct Book* nodeHead, char* bookISBN);void saveBookToFile(const char* filename, struct Book* headNode);void readBookFromFile(const char* filename, struct Book* headNode);void managerMenu();int mannagerKeyMenu();/*\t下面的是学生功能所用的函数*/struct Student* creatStudentHead();struct Student* creatStudent(struct studentInfo student);void insertStudentByHead(struct Student* headNode, struct studentInfo student);struct Student* searchStudentByID(struct Student* headNode, char* ID);void deleteStuByName(struct Student* nodeHead, char* bookName, char* ID);void saveStudentToFile(const char* filename, struct Student* headNode);void readStudentFromFile(const char* filename, struct Student* headNode);void studentMenu();int studentKeyMenu();// 主界面函数void mainMenu();void mainKeyDown();// 定义的全局变量struct Book* list;struct Student* STU;int main()&#123;\tSTU = creatStudentHead();  // 储存学生信息的链表\tlist = creatBookHead(); // 储存书籍信息的链表\treadBookFromFile(&quot;Book.txt&quot;, list);\treadStudentFromFile(&quot;Student.txt&quot;, STU);\twhile (1)\t&#123;\t\tmainKeyDown();\t\tsystem(&quot;pause&quot;);\t\tsystem(&quot;cls&quot;);\t&#125;\treturn 0;&#125;// 创建表头-&gt;Bookstruct Book* creatBookHead()&#123;\tstruct Book* headNode = (struct Book*)malloc(sizeof(struct Book));\theadNode-&gt;next = NULL;\treturn headNode;&#125;// 创建节点-&gt;Bookstruct Book* creatBook(struct bookInfo data)&#123;\tstruct Book* newNode = (struct Book*)malloc(sizeof(struct Book));\tnewNode-&gt;data = data;\tnewNode-&gt;next = NULL;\treturn newNode;&#125;// 表头法插入-&gt;Bookvoid insertBookByHead(struct Book* headNode, struct bookInfo data)&#123;\tstruct Book* newNode = creatBook(data);\tnewNode-&gt;next = headNode-&gt;next;\theadNode-&gt;next = newNode;&#125;// 打印链表-&gt;Bookvoid printBookList(struct Book* headNode)&#123;\tstruct Book* Pmove = headNode-&gt;next;\tprintf(&quot;书名            作者            ISBN            价格    数量\\n&quot;);\twhile (Pmove != NULL)\t&#123;\t\tprintf(&quot;%-14s\\t%-14s\\t%-13s\\t%.1lf\\t%d\\n&quot;, Pmove-&gt;data.name, Pmove-&gt;data.author, Pmove-&gt;data.ISBN, Pmove-&gt;data.price, Pmove-&gt;data.current_num);\t\tPmove = Pmove-&gt;next;\t&#125;&#125;// 指定查找 -&gt;书名struct Book* searchBookByName(struct Book* headNode, char* bookname)&#123;\tstruct Book* posNode = headNode-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.name, bookname))\t&#123;\t\tposNode = posNode-&gt;next;\t&#125;\treturn posNode;&#125;// 指定查找 -&gt; ISBNstruct Book* searchBookByISBN(struct Book* headNode, char* bookISBN)&#123;\tstruct Book* posNode = headNode-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.ISBN, bookISBN))\t&#123;\t\tposNode = posNode-&gt;next;\t&#125;\treturn posNode;&#125;// 指定删除 -&gt; 书名void deleteBookByName(struct Book* nodeHead, char* bookName)&#123;\tstruct Book* posLeftNode = nodeHead;\tstruct Book* posNode = nodeHead-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.name, bookName))\t&#123;\t\tposLeftNode = posNode;\t\tposNode = posLeftNode-&gt;next;\t&#125;\tposLeftNode-&gt;next = posNode-&gt;next;\tfree(posNode);\tposNode = NULL;&#125;// 指定删除 -&gt; ISBNvoid deleteBookByISBN(struct Book* nodeHead, char* bookISBN)&#123;\tstruct Book* posLeftNode = nodeHead;\tstruct Book* posNode = nodeHead-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;data.ISBN, bookISBN))\t&#123;\t\tposLeftNode = posNode;\t\tposNode = posLeftNode-&gt;next;\t&#125;\tposLeftNode-&gt;next = posNode-&gt;next;\tfree(posNode);\tposNode = NULL;&#125;// 指文件操作 存操作void saveBookToFile(const char* filename, struct Book* headNode)&#123;\tFILE* fp = fopen(filename, &quot;w&quot;);\tstruct Book* Pmove = headNode-&gt;next;\twhile (Pmove != NULL)\t&#123;\t\tfprintf(fp, &quot;%s\\t%s\\t%s\\t%.2lf\\t%d\\t%d\\t%d\\n&quot;, Pmove-&gt;data.name, Pmove-&gt;data.author, Pmove-&gt;data.ISBN, Pmove-&gt;data.price, Pmove-&gt;data.current_num, Pmove-&gt;data.flag, Pmove-&gt;data.num);\t\tPmove = Pmove-&gt;next;\t&#125;\tfclose(fp);&#125;// 写操作void readBookFromFile(const char* filename, struct Book* headNode)&#123;\tFILE* fp = fopen(filename, &quot;r&quot;);\tif (fp == NULL) // 第一次打开时的情况\t&#123;\t\tfp = fopen(filename, &quot;w+&quot;);\t&#125;\tstruct bookInfo tempData;\twhile (fscanf(fp, &quot;%s\\t%s\\t%s\\t%lf\\t%d\\t%d\\t%d\\n&quot;, tempData.name, tempData.author, tempData.ISBN, &amp;tempData.price, &amp;tempData.current_num, &amp;tempData.flag, &amp;tempData.num) != EOF)\t&#123;\t\tinsertBookByHead(list, tempData);\t&#125;\tfclose(fp);&#125;// 创建表头-&gt;Studentstruct Student* creatStudentHead()&#123;\tstruct Student* headNode = (struct Student*)malloc(sizeof(struct Student));\theadNode-&gt;next = NULL;\treturn headNode;&#125;// 创建节点-&gt;Studentstruct Student* creatStudent(struct studentInfo student)&#123;\tstruct Student* newNode = (struct Student*)malloc(sizeof(struct Student));\tnewNode-&gt;student = student;\tnewNode-&gt;next = NULL;\treturn newNode;&#125;// 表头法插入-&gt;Studentvoid insertStudentByHead(struct Student* headNode, struct studentInfo student)&#123;\tstruct Student* newNode = creatStudent(student);\tnewNode-&gt;next = headNode-&gt;next;\theadNode-&gt;next = newNode;&#125;// 查找学生 -&gt; IDstruct Student* searchStudentByID(struct Student* headNode, char* ID)&#123;\tstruct Student* posNode = headNode-&gt;next;\twhile (posNode != NULL &amp;&amp; strcmp(posNode-&gt;student.ID, ID))\t&#123;\t\tposNode = posNode-&gt;next;\t&#125;\treturn posNode;&#125;// 删除学生所借阅的书籍void deleteStuByName(struct Student* nodeHead, char* bookName, char* ID)&#123;\tstruct Student* Node = searchStudentByID(nodeHead, ID);\tstruct bookInfo temp = &#123; &quot;\\0&quot; &#125;;\tfor (int i = 0; i &lt; Node-&gt;student.current_number; i++)\t&#123;\t\tif (strcmp(Node-&gt;student.bookinfo[i].name, bookName))\t\t&#123;\t\t\tif (i == Node-&gt;student.current_number - 1)\t\t\t&#123;\t\t\t\tNode-&gt;student.bookinfo[i] = temp;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tfor (int j = i; j &lt; Node-&gt;student.current_number; )\t\t\t\t&#123;\t\t\t\t\tNode-&gt;student.bookinfo[j] = Node-&gt;student.bookinfo[j++];\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tNode-&gt;student.current_number--;&#125;// 存操作void saveStudentToFile(const char* filename, struct Student* headNode)&#123;\tFILE* fp = fopen(filename, &quot;w&quot;);\tstruct Student* Pmove = headNode-&gt;next;\twhile (Pmove != NULL)\t&#123;\t\tfprintf(fp, &quot;%s\\t%d\\n&quot;, Pmove-&gt;student.ID, Pmove-&gt;student.current_number);\t\tfor (int i = 0; i &lt; Pmove-&gt;student.current_number; i++)\t\t&#123;\t\t\tfprintf(fp, &quot;%s\\t%s\\t%s\\t%.1lf\\t%d\\t%d\\t%d\\n&quot;, Pmove-&gt;student.bookinfo[i].name, Pmove-&gt;student.bookinfo[i].author, Pmove-&gt;student.bookinfo[i].ISBN, Pmove-&gt;student.bookinfo[i].price, Pmove-&gt;student.bookinfo[i].current_num, Pmove-&gt;student.bookinfo[i].flag, Pmove-&gt;student.bookinfo[i].num);\t\t&#125;\t\tPmove = Pmove-&gt;next;\t&#125;\tfclose(fp);&#125;// 写操作void readStudentFromFile(const char* filename, struct Student* headNode)&#123;\tFILE* fp = fopen(filename, &quot;r&quot;);\tif (fp == NULL) // 第一次打开时的情况\t&#123;\t\tfp = fopen(filename, &quot;w+&quot;);\t&#125;\tstruct studentInfo tempData;\twhile (fscanf(fp, &quot;%s\\t%d\\n&quot;, tempData.ID, &amp;tempData.current_number) != EOF)\t&#123;\t\tfor (int i = 0; i &lt; tempData.current_number; i++)\t\t&#123;\t\t\tfscanf(fp, &quot;%s\\t%s\\t%s\\t%lf\\t%d\\t%d\\t%d\\n&quot;, tempData.bookinfo[i].name, tempData.bookinfo[i].author, tempData.bookinfo[i].ISBN, &amp;tempData.bookinfo[i].price, &amp;tempData.bookinfo[i].current_num, &amp;tempData.bookinfo[i].flag, &amp;tempData.bookinfo[i].num);\t\t&#125;\t\tinsertStudentByHead(STU, tempData);\t&#125;\tfclose(fp);&#125;// 主界面void mainMenu()&#123;\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                   欢迎使用图书管理系统                   |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |     [1].管理员登陆    [2].学生登陆    [0].退出系统       |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot;请选择：&quot;);&#125;// 管理员界面void managerMenu()&#123;\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot; |                       管理员端                           |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [1].新书信息录入                      |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [2].查看所有图书信息                  |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [3].图书信息查询                      |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [4].图书信息删除                      |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [5].返回主菜单                        |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [0].退出系统                          |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot;请选择：&quot;);&#125;// 管理员交互界面int mannagerKeyMenu()&#123;\tint tempkey = 0;\tstruct bookInfo tempBook; // 临时用来储存管理员输入的书籍信息\tstruct Book* result = NULL; // 用来接受搜索书籍信息的结果\tscanf(&quot;%d&quot;, &amp;tempkey);\tsystem(&quot;cls&quot;);\tswitch (tempkey)\t&#123;\tcase 1: // 登记图书\t&#123;\t\tprintf(&quot;\\a\\n请输入新图书信息：\\n\\n&quot;);\t\tprintf(&quot;====================================\\n&quot;);\t\tprintf(&quot;书名    作者    ISBN    价格    数量\\n&quot;);\t\tprintf(&quot;------------------------------------\\n&quot;);\t\tscanf(&quot;%s %s %s %lf %d&quot;, tempBook.name, tempBook.author, tempBook.ISBN, &amp;tempBook.price, &amp;tempBook.num);\t\ttempBook.flag = 0; // flag 赋值为0表示这个书籍没有被借出过，所有书籍都在库\t\ttempBook.current_num = tempBook.num; // 书籍刚入库时，现有的书籍数 和 原有书籍数时相同的\t\tinsertBookByHead(list, tempBook); // 连接到链表list\t\tsaveBookToFile(&quot;Book.txt&quot;, list); // 保存到文件\t\twhile (1) // 这个循环来实现重复录入书籍\t\t&#123;\t\t\tprintf(&quot;\\a&quot;);\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\tprintf(&quot;            [1].继续录入    [2].结束录入                \\n&quot;);\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\tint tempcase;\t\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\t\tif (tempcase == 1)\t\t\t&#123;\t\t\t\tprintf(&quot;\\n请输入新图书信息：\\n\\n&quot;);\t\t\t\tprintf(&quot;====================================\\n&quot;);\t\t\t\tprintf(&quot;书名    作者    ISBN    价格    数量\\n&quot;);\t\t\t\tprintf(&quot;------------------------------------\\n&quot;);\t\t\t\tscanf(&quot;%s %s %s %lf %d&quot;, tempBook.name, tempBook.author, tempBook.ISBN, &amp;tempBook.price, &amp;tempBook.num);\t\t\t\ttempBook.flag = 0;\t\t\t\ttempBook.current_num = tempBook.num;\t\t\t\tinsertBookByHead(list, tempBook);\t\t\t\tsaveBookToFile(&quot;Book.txt&quot;, list);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tbreak;\tcase 2: // 查看图书信息\t\tprintf(&quot;\\a\\t图书信息如下：\\n\\n&quot;);\t\tprintBookList(list); // 打印书籍信息到屏幕\t\tbreak;\tcase 3: // 图书信息查询\t&#123;\tC:\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [1].按图书名称查询                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [2].按图书编号查询                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [3].返回上一级菜单                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot;请选择：&quot;);\t\tint tempcase = 0;\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\tsystem(&quot;cls&quot;);\t\tswitch (tempcase)\t\t&#123;\t\tcase 1: // 图书名字查询\t\tA:\tprintf(&quot;请输入书籍名：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.name);\t\t\tresult = searchBookByName(list, tempBook.name); // 接收查询结果 \t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1: //\t\t\t\t\tgoto A;\t\t\t\t\tbreak;\t\t\t\tcase 2: // 返回上一级菜单 -&gt; 查询书籍菜单\t\t\t\t\tgoto C;\t\t\t\t\tbreak;\t\t\t\tcase 0: // 结束整个程序\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n书籍信息如下:\\n\\n&quot;);\t\t\t\tprintf(&quot;书名        作者        ISBN            价格    数量\\n&quot;);\t\t\t\tprintf(&quot;%-10s  %-10s\\t%-13s\\t%.1lf\\t%d\\n&quot;, result-&gt;data.name, result-&gt;data.author, result-&gt;data.ISBN, result-&gt;data.price, result-&gt;data.current_num);\t\t\t&#125;\t\t\tbreak;\t\tcase 2: // 通过ISBN来查询书籍\t\tB:\tprintf(&quot;请输入书籍的ISBN号：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.ISBN);\t\t\tresult = searchBookByISBN(list, tempBook.ISBN); // 接收查询结果\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找到相关书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1: // 继续搜索\t\t\t\t\tgoto B;\t\t\t\t\tbreak;\t\t\t\tcase 2: // 返回上一级 -&gt; 查询书籍界面\t\t\t\t\tgoto C;\t\t\t\t\tbreak;\t\t\t\tcase 0: // 结束整个程序\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n书籍信息如下:\\n\\n&quot;);\t\t\t\tprintf(&quot;书名        作者        ISBN            价格    数量\\n&quot;);\t\t\t\tprintf(&quot;%-10s  %-10s\\t%-13s\\t%.1lf\\t%d\\n&quot;, result-&gt;data.name, result-&gt;data.author, result-&gt;data.ISBN, result-&gt;data.price, result-&gt;data.current_num);\t\t\t&#125;\t\t\tbreak;\t\tcase 3:\t\t\treturn 0; // 直接结束此函数，成功回到了上一界面\t\t\tbreak;\t\t&#125;\t&#125;\tbreak;\tcase 4: // 图书信息删除\t&#123;\tD:\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [1].按图书名称删除                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [2].按图书编号删除                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [3].返回上一级菜单                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot;请选择：&quot;);\t\tint tempcase = 0;\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\tsystem(&quot;cls&quot;);\t\tswitch (tempcase)\t\t&#123;\t\tcase 1: // 书名法删除\t\tE:\tprintf(&quot;请输入书籍名：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.name);\t\t\tresult = searchBookByName(list, tempBook.name); // 接收结果\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找到相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续删除   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1: // 继续\t\t\t\t\tgoto E;\t\t\t\t\tbreak;\t\t\t\tcase 2: // 回到-&gt;删除菜单\t\t\t\t\tgoto D;\t\t\t\t\tbreak;\t\t\t\tcase 0: // 结束程序\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (result-&gt;data.flag == 1) // 书籍标记 flag 为1 表示有图书未还，不能删除书籍\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a \\n\\n此书正在出借，无法删除信息！\\n\\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;   [1].重新搜索  [2].返回管理员功能菜单  [0].退出系统   \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\t\tint tempkey = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;tempkey);\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tswitch (tempkey)\t\t\t\t\t&#123;\t\t\t\t\tcase 1:\t\t\t\t\t\tgoto E;\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\treturn 0;\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\t\tSleep(500);\t\t\t\t\t\texit(0);\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a\\n\\n  确认删除？\\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                 [1].是      [2].否                     \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tint tempkey = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;tempkey);\t\t\t\t\tif (tempkey == 1)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;\\a删除成功\\n&quot;);\t\t\t\t\t\tdeleteBookByName(list, tempBook.name);\t\t\t\t\t\tsaveBookToFile(&quot;Book.txt&quot;, list);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tbreak;\t\tcase 2: // ISBN法删除\t\tF:\tprintf(&quot;请输入书籍的ISBN：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.ISBN);\t\t\tresult = searchBookByISBN(list, tempBook.ISBN); // 接收结果\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找到相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续删除   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1:\t\t\t\t\tgoto F;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tgoto D;\t\t\t\t\tbreak;\t\t\t\tcase 0:\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (result-&gt;data.flag == 1) // 有书籍未还回\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a \\n\\n此书正在出借，无法删除信息！\\n\\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;   [1].重新搜索  [2].返回管理员功能菜单  [0].退出系统   \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\t\tint tempkey = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;tempkey);\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tswitch (tempkey)\t\t\t\t\t&#123;\t\t\t\t\tcase 1:\t\t\t\t\t\tgoto F;\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\treturn 0;\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\t\tSleep(500);\t\t\t\t\t\texit(0);\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a\\n\\n  确认删除？\\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                 [1].是      [2].否                     \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tint tempkey = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;tempkey);\t\t\t\t\tif (tempkey == 1)\t\t\t\t\t&#123;\t\t\t\t\t\tprintf(&quot;\\a删除成功\\n&quot;);\t\t\t\t\t\tdeleteBookByISBN(list, tempBook.ISBN);\t\t\t\t\t\tsaveBookToFile(&quot;Book.txt&quot;, list);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tbreak;\t\tcase 3: // 返回管理员界面\t\t\treturn 0;\t\t\tbreak;\t\t&#125;\t&#125;\tbreak;\tcase 5: // 返回主界面\t\treturn 1; // 这里的返回值在 mainKeyDown() 函数中有作用\t\tbreak;\tcase 0: // 退出系统\t\tsystem(&quot;cls&quot;);\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tSleep(500);\t\texit(0);\t\tbreak;\tdefault:\t\tprintf(&quot;error\\n&quot;);\t\tbreak;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);\treturn 0;&#125;// 学生界面void studentMenu()&#123;\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot; |                        学生端                            |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [1].图书信息查询                      |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [2].书籍借阅                          |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [3].书籍归还                          |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [4].返回主菜单                        |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; |                    [0].退出系统                          |\\n&quot;);\tprintf(&quot; |                                                          |\\n&quot;);\tprintf(&quot; ============================================================\\n&quot;);\tprintf(&quot;请选择：&quot;);&#125;// 学生交互界面int studentKeyMenu()&#123;\tint tempkey = 0;\tstruct bookInfo tempBook;\tstruct Book* result = NULL; // 用来存放查询书籍信息的结果\tstruct Student* outcome = NULL; // 用来存放查询学生信息的结果\tscanf(&quot;%d&quot;, &amp;tempkey);\tsystem(&quot;cls&quot;);\tswitch (tempkey)\t&#123;\tcase 1: // 图书信息查询\t&#123;\tC:\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [1].按图书名称查询                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [2].按图书编号查询                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [3].返回上一级菜单                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot;请选择：&quot;);\t\tint tempcase = 0;\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\tsystem(&quot;cls&quot;);\t\tswitch (tempcase)\t\t&#123;\t\tcase 1:\t\tA:\tprintf(&quot;请输入书籍名：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.name);\t\t\tresult = searchBookByName(list, tempBook.name);\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1:\t\t\t\t\tgoto A;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tgoto C;\t\t\t\t\tbreak;\t\t\t\tcase 0:\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n书籍信息如下:\\n\\n&quot;);\t\t\t\tprintf(&quot;书名        作者        ISBN            价格    数量\\n&quot;);\t\t\t\tprintf(&quot;%-10s  %-10s\\t%-13s\\t%.1lf\\t%d\\n&quot;, result-&gt;data.name, result-&gt;data.author, result-&gt;data.ISBN, result-&gt;data.price, result-&gt;data.num);\t\t\t&#125;\t\t\tbreak;\t\tcase 2:\t\tB:\tprintf(&quot;请输入书籍的ISBN号：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.ISBN);\t\t\tresult = searchBookByISBN(list, tempBook.ISBN);\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找到相关书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1:\t\t\t\t\tgoto B;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tgoto C;\t\t\t\t\tbreak;\t\t\t\tcase 0:\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n书籍信息如下:\\n\\n&quot;);\t\t\t\tprintf(&quot;书名        作者        ISBN            价格    数量\\n&quot;);\t\t\t\tprintf(&quot;%-10s  %-10s\\t%-13s\\t%.1lf\\t%d\\n&quot;, result-&gt;data.name, result-&gt;data.author, result-&gt;data.ISBN, result-&gt;data.price, result-&gt;data.num);\t\t\t&#125;\t\t\tbreak;\t\t\tbreak;\t\tcase 3:\t\t\treturn 0; // 直接结束此函数，成功回到了上一界面\t\t\tbreak;\t\t&#125;\t&#125;\tbreak;\tcase 2: // 图书借阅\t&#123;\tD:\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [1].按图书名借阅                      |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [2].按图书编号借阅                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [3].返回上一级菜单                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot;请选择：&quot;);\t\tint tempcase = 0;\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\tsystem(&quot;cls&quot;);\t\tswitch (tempcase)\t\t&#123;\t\tcase 1:\t\tE:\tprintf(&quot;\\n请输入书籍名：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.name);\t\t\tresult = searchBookByName(list, tempBook.name);\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1:\t\t\t\t\tgoto E;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tgoto D;\t\t\t\t\tbreak;\t\t\t\tcase 0:\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (result-&gt;data.current_num &gt; 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a\\n\\n 确定要借阅书籍《%s》？\\n&quot;, result-&gt;data.name);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   [1].是      [0].否                   \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tint a = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;a);\t\t\t\t\tif (a == 1)\t\t\t\t\t&#123;\t\t\t\t\t\tstruct studentInfo tempStudent = &#123;\t\t\t\t\t\t\t&quot;\\0&quot;,\t\t\t\t\t\t\t0,\t\t\t\t\t\t&#125;;\t\t\t\t\t\tprintf(&quot;\\a\\n请输入你的学号：&quot;);\t\t\t\t\t\tscanf(&quot;%s&quot;, tempStudent.ID);\t\t\t\t\t\toutcome = searchStudentByID(STU, tempStudent.ID); // 查找此学生\t\t\t\t\t\tif (outcome == NULL) // 从未借过书\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tresult-&gt;data.flag = 1; // 给图书打上有借出的标记\t\t\t\t\t\t\tresult-&gt;data.current_num--; // 书籍数减一\t\t\t\t\t\t\ttempStudent.bookinfo[0] = result-&gt;data;\t\t\t\t\t\t\ttempStudent.current_number++;\t\t\t\t\t\t\tinsertStudentByHead(STU, tempStudent);\t\t\t\t\t\t\tsaveStudentToFile(&quot;Student.txt&quot;, STU);\t\t\t\t\t\t\tprintf(&quot;\\n借阅成功\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse if (outcome != NULL &amp;&amp; outcome-&gt;student.current_number &lt; MAXNUM) // 所借书籍数未超过 MAXNUM\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tresult-&gt;data.flag = 1; // 给图书打上有借出的标记\t\t\t\t\t\t\tresult-&gt;data.current_num--; // 书籍数减一\t\t\t\t\t\t\toutcome-&gt;student.bookinfo[outcome-&gt;student.current_number] = result-&gt;data;\t\t\t\t\t\t\toutcome-&gt;student.current_number++;\t\t\t\t\t\t\tsaveStudentToFile(&quot;Student.txt&quot;, STU);\t\t\t\t\t\t\tprintf(&quot;\\n借阅成功\\n&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse if (outcome != NULL &amp;&amp; outcome-&gt;student.current_number &gt;= MAXNUM)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;\\a\\n抱歉，你所借书籍数目已经超过最大书籍数\\n&quot;);\t\t\t\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\t\t\treturn 0;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\treturn 0;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tbreak;\t\tcase 2:\t\tF:  printf(&quot;\\n请输入书籍的ISBN：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.ISBN);\t\t\tresult = searchBookByISBN(list, tempBook.ISBN);\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n未找相关的书籍！\\n\\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;    [1].继续搜索   [2].返回上一级菜单   [0].退出系统    \\n&quot;);\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\tprintf(&quot;请选择：&quot;);\t\t\t\tint temp = 0;\t\t\t\tscanf(&quot;%d&quot;, &amp;temp);\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\tswitch (temp)\t\t\t\t&#123;\t\t\t\tcase 1:\t\t\t\t\tgoto F;\t\t\t\t\tbreak;\t\t\t\tcase 2:\t\t\t\t\tgoto D;\t\t\t\t\tbreak;\t\t\t\tcase 0:\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\t\t\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\t\t\t\tSleep(500);\t\t\t\t\texit(0);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (result-&gt;data.current_num &gt; 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\a\\n\\n 确定要借阅书籍《%s》？\\n&quot;, result-&gt;data.name);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tprintf(&quot;                   [1].是      [0].否                   \\n&quot;);\t\t\t\t\tprintf(&quot; -------------------------------------------------------\\n&quot;);\t\t\t\t\tint a = 0;\t\t\t\t\tscanf(&quot;%d&quot;, &amp;a);\t\t\t\t\tif (a == 1)\t\t\t\t\t&#123;\t\t\t\t\t\tstruct studentInfo tempStudent = &#123;\t\t\t\t\t\t\t&quot;\\0&quot;,\t\t\t\t\t\t\t0,\t\t\t\t\t\t&#125;;\t\t\t\t\t\tprintf(&quot;\\a\\n请输入你的学号：&quot;);\t\t\t\t\t\tscanf(&quot;%s&quot;, tempStudent.ID);\t\t\t\t\t\toutcome = searchStudentByID(STU, tempStudent.ID); // 查找此学生\t\t\t\t\t\tif (outcome == NULL) // 从未借过书\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tresult-&gt;data.flag = 1; // 给图书打上有借出的标记\t\t\t\t\t\t\tresult-&gt;data.current_num--; // 书籍数减一\t\t\t\t\t\t\ttempStudent.bookinfo[0] = result-&gt;data;\t\t\t\t\t\t\ttempStudent.current_number++;\t\t\t\t\t\t\tinsertStudentByHead(STU, tempStudent);\t\t\t\t\t\t\tsaveStudentToFile(&quot;Student.txt&quot;, STU);\t\t\t\t\t\t\tprintf(&quot;\\n借阅成功!&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse if (outcome != NULL &amp;&amp; outcome-&gt;student.current_number &lt; MAXNUM) // 所借书籍数未超过 MAXNUM\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tresult-&gt;data.flag = 1; // 给图书打上有借出的标记\t\t\t\t\t\t\toutcome-&gt;student.bookinfo[outcome-&gt;student.current_number] = result-&gt;data;\t\t\t\t\t\t\toutcome-&gt;student.current_number++;\t\t\t\t\t\t\tsaveStudentToFile(&quot;Student.txt&quot;, STU);\t\t\t\t\t\t\tprintf(&quot;\\n借阅成功!&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse if (outcome != NULL &amp;&amp; outcome-&gt;student.current_number &gt;= MAXNUM)\t\t\t\t\t\t&#123;\t\t\t\t\t\t\tprintf(&quot;\\a\\n抱歉，你所借书籍数目已经超过最大书籍数\\n\\n&quot;);\t\t\t\t\t\t\tsystem(&quot;pause&quot;);\t\t\t\t\t\t\tsystem(&quot;cls&quot;);\t\t\t\t\t\t\treturn 0;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\telse\t\t\t\t\t&#123;\t\t\t\t\t\treturn 0;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tbreak;\t\tcase 3:\t\t\treturn 0;\t\t\tbreak;\t\t&#125;\t&#125;\tbreak;\tcase 3: // 图书归还\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [1].归还书籍                          |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; |                    [2].返回上一级菜单                    |\\n&quot;);\t\tprintf(&quot; |                                                          |\\n&quot;);\t\tprintf(&quot; ============================================================\\n&quot;);\t\tprintf(&quot;请选择：&quot;);\t\tint tempcase = 0;\t\tscanf(&quot;%d&quot;, &amp;tempcase);\t\tsystem(&quot;cls&quot;);\t\tif (tempcase == 1)\t\t&#123;\t\t\tprintf(&quot;\\n请输入要归还的书籍的名字：&quot;);\t\t\tscanf(&quot;%s&quot;, tempBook.name);\t\t\tresult = searchBookByName(list, tempBook.name);\t\t\tif (result == NULL)\t\t\t&#123;\t\t\t\tprintf(&quot;\\a\\n此书籍不属于本图书馆\\n\\n&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tchar ID[IDLength + 1];\t\t\t\tprintf(&quot;\\n请输入你的学号：&quot;);\t\t\t\tscanf(&quot;%s&quot;, ID);\t\t\t\tdeleteStuByName(STU, tempBook.name, ID);\t\t\t\tprintf(&quot;\\a\\n归还成功\\n\\n&quot;);\t\t\t\tsaveStudentToFile(&quot;Student.txt&quot;, STU);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn 0;\t\t&#125;\t\tbreak;\tcase 4:\t\treturn 1;\t\tbreak;\tcase 0: // 结束程序\t\tsystem(&quot;cls&quot;);\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tSleep(500);\t\texit(0);\t\tbreak;\tdefault:\t\tprintf(&quot;error\\n&quot;);\t\tbreak;\t&#125;\tsystem(&quot;pause&quot;);\tsystem(&quot;cls&quot;);\treturn 0;&#125;// 主交互界面void mainKeyDown()&#123;A:\tmainMenu(); // 主界面函数; 标签A用来标记，在下面会用到\tint tempkey = 0;\tscanf(&quot;%d&quot;, &amp;tempkey);\tsystem(&quot;cls&quot;);\tswitch (tempkey)\t&#123;\tcase 1: // 进入管理员端\t\twhile (1)\t\t&#123;\t\t\tmanagerMenu();\t\t\tint tempcase = mannagerKeyMenu();\t\t\tif (tempcase == 1) // 这个操作使用来实现功能中的返回主函数\t\t\t&#123;\t\t\t\tgoto A;\t\t\t&#125;\t\t&#125;\t\tbreak;\tcase 2: // 进入学生端\t\twhile (1)\t\t&#123;\t\t\tstudentMenu();\t\t\tint tempcase = studentKeyMenu();\t\t\tif (tempcase == 1) // 这个操作使用来实现功能中的返回主函数\t\t\t&#123;\t\t\t\tgoto A;\t\t\t&#125;\t\t&#125;\t\tbreak;\tcase 0: // 程序结束\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tprintf(&quot;                   -=  感谢使用，再见！ =-                   \\n&quot;);\t\tprintf(&quot; ------------------------------------------------------------\\n&quot;);\t\tSleep(500);\t\texit(0);\t\tbreak;\tdefault:\t\tprintf(&quot;error\\n&quot;);\t\tbreak;\t&#125;&#125;\n\n","categories":["项目","C"],"tags":["C语言"]},{"title":"java面向对象编程","url":"/2022/07/15/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"java笔记\n\n\n基础内容基本数据类型byte：\n\n最大值：127（2^7-1）\n\n最小值：128（-2^7）\n\n默认值：0\n\n例子：byte a &#x3D; 100;\n\n\nshort：\n\n最大值：32767（2^15 - 1）\n最小值：- 32768（-2^15）\n默认值：0\n例子：short r &#x3D; 2000\n\nint：\n\n最大值是 2,147,483,647（2^31 - 1）\n最小值是 -2,147,483,648（-2^31）\n默认值是 0 ；\n例子：int a &#x3D; 100000\n\nlong：\n\n最大值：9,223,372,036,854,775,807（2^63 -1）\n最小值：-9,223,372,036,854,775,808（-2^63）\n默认值：0L（L是不分大小写的，但是写成大写不容易看错）\n例子：long a &#x3D; 10L\n\nfloat：\n\n单精度32位浮点数\n例子：float num &#x3D; 233.45f\n\ndouble：\n\n双精度64位浮点数\n例子：double num &#x3D; 7\n\nboolean：\n\n布尔类型，用来表示真假\n取值：true和false\n例子：boolean flag &#x3D; true\n\nchar：\n\n字符类型\nchar a &#x3D; ‘A’\njava中字符串不是字符数组，它是引用类型\n\n控制语句输入输出输出\n使用System.out.println()来输出\nprintln是print line缩写 -&gt; 输出并换行\npublic class Main &#123;    public static void main(String[] args) &#123;        System.out.print(&quot;A,&quot;);        System.out.print(&quot;B,&quot;);        System.out.print(&quot;C.&quot;);        System.out.println();        System.out.println(&quot;END&quot;);    &#125;&#125;\n\n格式化输出\n格式化方式与C可以说是一样\npublic class Main &#123;    public static void main(String[] args) &#123;        double d = 3.1415926;        System.out.printf(&quot;%.2f\\n&quot;, d); // 显示两位小数3.14        System.out.printf(&quot;%.4f\\n&quot;, d); // 显示4位小数3.1416    &#125;&#125;\n\n输入\n输入比输出麻烦一些，需要导包使用Scanner类\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入你的名字&quot;);        String name = scanner.nextLine();        System.out.println(&quot;输入你的年龄&quot;);        int age = scanner.nextInt();        System.out.println(&quot;你的名字是：&quot;+name+&quot;\\n你的年龄是：&quot;+age);    &#125;&#125;\n\n流程控制for each循环\nfor each循环的变量n不再是计数器，而是直接对应到数组的每个元素。\npublic class Main &#123;    public static void main(String[] args) &#123;        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;        for (int n : ns) &#123;            System.out.println(n);        &#125;    &#125;&#125;\n\n数组操作java里面的多维数组可以每个数组里面的元素个数不相同\nint[][] ns = &#123;    &#123; 1, 2, 3, 4 &#125;,    &#123; 5, 6 &#125;,    &#123; 7, 8, 9 &#125;&#125;;\n\n打印二维数组\nfor (int[] arr : ns) &#123;    for (int n : arr) &#123;        System.out.print(n);        System.out.print(&#x27;, &#x27;);    &#125;    System.out.println();&#125;\n\n使用Arrays.deepToString()打印数组\n// 需要导包import java.util.Arrays;System.out.println(Arrays.deepToString(ns));/** 输出结果* [[1, 2, 3, 4], [5, 6], [7, 8, 9]]*/\n\n三维数组的定义\nint[][][] ns = &#123;    &#123;        &#123;1, 2, 3&#125;,        &#123;4, 5, 6&#125;,        &#123;7, 8, 9&#125;    &#125;,    &#123;        &#123;10, 11&#125;,        &#123;12, 13&#125;    &#125;,    &#123;        &#123;14, 15, 16&#125;,        &#123;17, 18&#125;    &#125;&#125;;\n\n面向对象编程","categories":["笔记","java"],"tags":["OOP","java"]},{"title":"kmp算法","url":"/2022/11/05/kmp%E7%AE%97%E6%B3%95/","content":" 字符串匹配算法中的 kmp 算法\n \n\nKMP 算法思路对于字符串模式匹配，BF方法我们都知道，但是它的运行时间非常的慢，所以就有了KMP算法，KMP算法其实算是牺牲了空间来换取更快的时间。\n使用 pat 表示模式串，长度为 m ， txt 表示主串，长度为 n \n在BF算法中：使用了指针 i 和 j 来之时主串和模式串的位置，而且每次匹配失败的时候，主串的 i 就会就会回溯。\nKMP 的核心要点就是指针 i 不会像BF算法那样回溯，而是移动 j 的位置，所以需要一个 next[j] 数组来储存每一个 j 所对应的下一个 j \nnext数组\n前缀字符串指的是位于模式串起始位置的字符串，例如模式串 “ABCD”，则 “A”、”AB”、”ABC” 以及 “ABCD” 都属于前缀字符串；后缀字符串指的是位于串结尾处的字符串，还拿模式串 “ABCD” 来说，”D”、”CD”、”BCD” 和 “ABCD” 为后缀字符串。\n\n现在有串 P&#x3D;abaabca ，各个子串的最大公共前后缀长度如下表所示\n\n这个时候串 p 的每一个字符就跟最大字符串产生了一一对应关系\n\n这个表的含义是在当前字符作为最后一个字符时，当前子串所拥有的公共前后缀最长长度\n现在引出 next 数组，next 数组的值是当前字符的前一个字符作为最后一个字符时，当前字串所拥有的公共前后缀最大长度。也就是把上面表的每一个都向右移动一位，也就是下表：\n\n\nnext 数组的使用\n当主串与模式串不匹配的时候，将 j = next[j] 这就相当于将模式串向右移动了 j - next[j] 位\n\n\n递推求解 next 数组对于 next 数组，next[0] = -1, next[1] = 0 这是已知的，所以变成了当 j&gt;1 时，如果我们已知了next[j]，求next[j+1]\n\n第一种情况：pat[j] 刚好是最大后缀的最后一个字符：pat[i] = pat[k]\n\n\n这个时候对于下一个字符来说，它的 next 数组的值刚好是前一个 next 值加一：next[j + 1] = next[j] + 1\n\n第二种情况：pat[j] 不是最大后缀(这个后缀是第一种情况的那种后缀)的最后一个字符：pat[i] != pat[k]\n\n\n这个时候虽然不等了，但是并不代表 pat[j] 不能作为最大后缀的最大字符，比如取前缀的 “AB” 依然可以配对\n但是如何找呢？\npat[j] 前面有一段已匹配的字符串 k ，他们的后缀相同，对于 pat[k] ，它前面有一段已匹配的字符串 L，它们后缀相同，这就表明了 L 的后缀与 K 的后缀是相同的，这样的话如果 pat[next[k]] = pat[j] 的话不就匹配成功了。所以就有了 k = next[k]\n\n代码void getNext(char* pat,int *next) &#123;\tint k = -1, j = 0;\tnext[0] = -1;\twhile (j &lt; strlen(pat)-1) &#123;\t\tif (k == -1 || pat[k]==pat[j]) &#123;\t\t\tk++;\t\t\tj++;\t\t\tnext[j] = k;\t\t&#125; else &#123;\t\t\tk = next[k];\t\t&#125;\t&#125;&#125;\n\n因为 next[0] 已经赋值过了，且在循环里面 j 是先加在使用的，所以 while 是 j &lt; strlen(pat)-1\nkmp代码void getNext(char* pat,int *next) &#123;\tint k = -1, j = 0;\tnext[0] = -1;\twhile (j &lt; strlen(pat)-1) &#123;\t\tif (k == -1 || pat[k]==pat[j]) &#123;\t\t\tk++;\t\t\tj++;\t\t\tnext[j] = k;\t\t&#125; else &#123;\t\t\tk = next[k];\t\t&#125;\t&#125;&#125;int kmp(char* txt, char* pat) &#123;\tif (txt == NULL || pat == NULL)&#123;\t\treturn -1;\t&#125;\tint p = (int)strlen(txt);\tint q = (int)strlen(pat);\tint* next = malloc(sizeof(int) * strlen(pat));\tif (next == NULL) &#123;\t\treturn -1;\t&#125;\tgetNext(pat, next);\tint i = 0, j = 0;\twhile ((i &lt; p) &amp;&amp; (j &lt; q)) &#123;\t\tif (j == -1 || txt[i] == pat[j]) &#123;\t\t\ti++;\t\t\tj++;\t\t&#125; else &#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tfree(next);\tnext = NULL;\tif (j == strlen(pat)) &#123;\t\treturn i - j;\t&#125; else &#123;\t\treturn -1;\t&#125;&#125;\n\n代码里面循环的判断不能直接使用 strlen 函数，因为 strlen 函数返回的是 size_t 类型；\n\n参考KMP算法详解_yyzsir的博客-CSDN博客_kmp算法\n\n","tags":["C语言","数据结构与算法"]},{"title":"free函数删除链表节点报错问题","url":"/2022/08/09/free%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","content":"写程序时遇到的一个bug，其实也不算是bug应该算是我粗心导致的错误。\n\n\n今天在写链表指定删除的时候，程序一旦运行会崩溃，cmd.exe还关闭不了，只有等重启之后才能关闭。\n最后调试才发现一旦运行到free函数就会崩溃，非常的懵逼。\nfree()的调用方式是：void  free(void  *ptr),释放由ptr所指的内存，并将它返回给堆，以便这些内存成为再分配时的可用内存。但是free()函数并不能将指针ptr赋空。\n所以，对于对于用malloc分配空间的指针p, 使用过后要这样释放：\n\nfree(p);\np&#x3D;NULL;\n\n在我找了一段时间后发现的问题所在内存溢出或者说内存分配出现了问题\n下面是我的代码的一部分：\n// 创建表头struct Node*creatHead()&#123;\t// 动态内存申请\tstruct Node* headnode = (struct Node*)malloc(sizeof(struct Node*)); \theadnode-&gt;next = NULL;\treturn headnode;&#125;;// 创建节点struct Node* creatNode(int data)&#123;\tstruct Node* newNode = (struct Node*)malloc(sizeof(struct Node*));\tnewNode-&gt;data = data;\tnewNode-&gt;next = NULL;\treturn newNode;&#125;\n\n// 指定数据删除void deleteNodeByData(struct Node* Nodehead, int posdata)&#123;\tstruct Node* posleftNode = Nodehead;\tstruct Node* posNode = Nodehead-&gt;next;\t//查找删除节点\twhile (posNode != NULL &amp;&amp; posNode-&gt;data != posdata)\t&#123;\t\tposleftNode = posNode;\t\tposNode = posleftNode-&gt;next;\t&#125;\t//判断查找结果\tif (posNode == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tposleftNode-&gt;next = posNode-&gt;next;\t\tfree(posNode);\t\tposNode = NULL;\t&#125;&#125;\n\n上面代码的问题就出现在创建动态链表的时候malloc(sizeof(struct Node*))出现了问题\n\nsizeof(struct Node)  &#x3D; 16\nsizeof(struct Node*) &#x3D; 8\n\n在这个程序中，每次我们分配一个8字节的大小给节点，但在下面赋值的时候有超过了8字节，当我们free的时候，给free函数一个指针，但是在内存中已经乱了，不是我们想要的地址了，那个时候我们free掉的不是我们想要free的节点，而是不知道什么东西让我们free了，这个时候程序就崩溃了。\n","categories":["笔记","C"],"tags":["C语言","编译器报错"]},{"title":"VS2022使用scanf的方法","url":"/2022/09/11/VS2022%E4%BD%BF%E7%94%A8scanf%E7%9A%84%E6%96%B9%E6%B3%95/","content":"正常打开一个项目后，按照下面方法操作即可\n\n\n\nvs2020 -&gt; 项目 -&gt; 属性 -&gt; C&#x2F;C++ -&gt; 预处理器 -&gt; 预处理器定义 -&gt; 编辑\n\n加上：\n_CRT_SECURE_NO_WARNINGS\n\n\n","categories":["笔记","C"],"tags":["C语言","VS2022"]},{"title":"双向链表与循环链表","url":"/2022/11/05/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","content":"特殊链表\n\n\n双向链表和循环链表对于单链表来说查找前驱结点非常的艰难\n为了解决这种查找前驱结点非常麻烦的问题，可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：\n\n这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表称为双向链表（双链表）\n首先定义结构体：\ntypedef int elemType;    typedef struct ListNode &#123;      elemType element;      struct ListNode *next;  // 后继节点    struct ListNode *prev;  // 前驱结点&#125; *Node;\n\n初始化链表：前驱和后继都设置为 NULL\nvoid initList(Node list) &#123;      list-&gt;prev = NULL;      list-&gt;next = NULL;  &#125;\n\n插入节点对于插入操作一般都是找到要插入节点的前驱节点，所以插入新的节点的时候一般是先把新节点与后面的节点相连接然后在与前驱节点相连接\n\n当新的结点插入之后，新的结点的后继结点就是原本在此位置上的结点，所以先将待插入结点的后继指针指向此位置上的结点：\n\n由于是双向链表，所以需要将原本在此位置上的结点的前驱指针指向新的结点：\n\n接下来是前驱结点，首先将前驱结点的后继指针修改为新的结点：\n\n 最后将新的结点的前驱指针指向前驱结点：\n\n按照思路设计函数：\nbool insertList(Node head, elemType element, int index) &#123;      if (index &lt; 1) &#123;          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123;          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      // 上面的操作是为了找到要插入节点的前一个节点      Node node = (Node) malloc(sizeof(struct ListNode)); // 创建新的节点      if (node == NULL) &#123;          return false;      &#125;      node-&gt;element = element;      // 首先处理后继结点，现在有两种情况，一种是后继结点不存在的情况，还有一种是后继结点存在的情况      if (head-&gt;next == NULL) &#123; // 后继节点不存在直接后继节点为NULL          node-&gt;next = NULL;      &#125; else &#123;          node-&gt;next = head-&gt;next;          head-&gt;next-&gt;prev = node;      &#125;      head-&gt;next = node; //接着是前驱结点，直接操作就行      node-&gt;prev = head;      return true;  &#125;\n\n这样，我们就编写好了双向链表的插入操作，来测试一下吧：\nint main() &#123;      struct ListNode head;      initList(&amp;head);      for (int i = 0; i &lt; 5; ++i) &#123;          insertList(&amp;head, i * 100, i);      &#125;        Node node = &amp;head;   //先来正向遍历一次      do &#123;          node = node-&gt;next;          printf(&quot;%d -&gt; &quot;, node-&gt;element);      &#125; while (node-&gt;next != NULL);        printf(&quot;\\n&quot;);   //再来反向遍历一次      do &#123;          printf(&quot;%d -&gt; &quot;, node-&gt;element);          node = node-&gt;prev;      &#125; while (node-&gt;prev != NULL);      return 0;  &#125;\n\n可以看到结果没有问题：\n\n无论是正向遍历还是反向遍历，都可以正常完成，相比单链表的灵活度更大\n删除节点\n只需将前驱结点和后继结点的指向修改即可：\n\n接着直接删除对应的结点即可：\n\n函数实现：\nbool deleteList(Node head, int index) &#123;      if (index &lt; 1) &#123;          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123;          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      if (head-&gt;next == NULL) &#123; // 这个表示要删除的节点不存在已经超出了链表          return false;      &#125;      Node temp = head-&gt;next;      if (head-&gt;next-&gt;next == NULL) &#123; // 要删除的节点为最后一个节点          head-&gt;next = NULL;      &#125; else &#123;          head-&gt;next-&gt;next-&gt;prev = head;          head-&gt;next = head-&gt;next-&gt;next;      &#125;      free(temp);      temp = NULL;      return true;  &#125;\n\n循环链表循环链表，这种链表实际上和链表是一样的，但是它的最后一个结点，是与头结点相连的，双向链表和单向链表都可以做成这样的环形结构，单链表为例：\n\n这种类型的链表实际上与普通链表的唯一区别就在于最后是否连接到头结点，因此循环链表支持从任意一个结点出发都可以到达任何的结点，而普通的链表则只能从头结点出发才能到达任意结点，同样也是为了更灵活而设计的。\n对于循环链表的结束，当节点的next节点指向的是head节点的时候就表示链表结束\n","tags":["C语言","数据结构与算法"]},{"title":"文件读写函数","url":"/2022/07/16/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0/","content":"C语言中关于文件读写的函数\n\n\n字符读写字符写入文件函数 fputcfputc函数的原型如下：\nint fputc( int c, FILE *fp );\n\n参数说明：    其中，c是要写入的字节，它虽被定义为整型，但只使用最低位的一字节，fp是文件指针。\nfputc的功能:    将字节c输出至fp所指向的文件。如果成功，位置指针自动后 移1字节的位置，并且返回c；否则返回EOF。\n从文件中读取字符 fgetcfgetc函数的原型如下:\nint fgetc( FILE *fp );\n\n参数说明：    其中fp为文件指针。\nfgetc的功能:    从fp所指向的文件中读取一个字节，如果成功则返回读取的字节，位置指针自动后移1字节的位置；否则返回EOF。\n字符串的读写字符串写入文件函数 fputsfputs函数的原型如下：\nint fputs( const char *s, FILE *fp );\n\n参数说明：    其中，s是要写入的字符串，fp是文件指针。\nfputs的功能：    将字符串s输出至fp所指向的文件（不含’\\0’）。如果成功，位置指针自动后移，函数返回一个非负整数；否则返回EOF。\n从文件中读取字符 fgetsfgets函数的原型如下：\nchar *fgets( char *s， int n， FILE *fp );\n\n参数说明：    其中，s指向待赋值字符串的首地址，n是控制读取个数的参数，fp为文件指针。 \nfgets的功能：    从位置指针开始读取 一行或n-1个字符，并存入s，存储时自动在字符串结尾加上’\\0’。如果函数执行成功，位置指针自动后移，并返回s的值，否则返回NULL。\n块数据读写所谓块读写，就是读写n块以m个字节为单位的二进制数据，可以是一个字符（一个字符为一字节，则块大小为1×1),可以是一个长度为n字符串（块大小1×n），可以是长度为n的整型数组（整型以4字节算，块大小4×n），也可以是结构体等任意数据类型，并没有什么限制。\n向文件中写入块数据fwritefwrite函数的原型如下：\nsize_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );\n\n参数说明：    ptr：指向保存读写数据的内存的指针，它可以指向数组、变量、结构体等。    size：表示每个数据块的字节数。    count：表示要读写的数据块的块数。    fp：表示文件指针。    理论上，每次读写 size*count 个字节的数据。\nfwrite的功能：    从内存中的ptr指向的地址开始，将连续n*size字节的内容写入fp文件中。该函数的返回值是实际写入的数据块个数。\n从文件中读取块数据freadfread函数的原型如下：\nsize_t fread ( void *ptr, size_t size, size_t count, FILE *fp );\n&#x2F;&#x2F;size_t 是在 stddef.h 头文件中使用 typedef 定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。\n参数说明：    见[[文件读写函数#^ece6a5|fwrite]]\nfread的功能：    从文件fp中，连续读取n*size字节的内容，并存入ptr指向的内存空间。该函数的返回值是实际读入的数据块个数。\n格式化读写格式化读写函数包括fprintf和fscanf两个函数，它们只用于文本文件的读写，不能用于二进制文件的读写。文本文件与二进制文件的区别下面注意点中有介绍。\n格式化写入文件fprintffprintf函数的原型如下：\nint fprintf( FILE *fp, const char* format, 输出参数1, 输出参数2… );\n\n参数说明:    其中，fp是文件指针，format为格式控制字符串，输出参数列表为待输出的数据。 \nfprintf的功能：    根据指定的格式（format参数）发送数据（输出参数）到文件fp。例：\n#include &lt;stdio.h&gt;int main()&#123;    FILE *fp;    fp = fopen(&quot;a.txt&quot;,&quot;w&quot;);    int a = 10;    double f = 11.11;    fprintf(fp, &quot;%d%lf&quot;, a, f);    fclose(fp);    return 0;&#125;\n\n注意：fprintf()按格式输入到流，其用法和printf()相同，不过不是写到控制台，而是写到流罢了。注意的是返回值为此次操作写入到文件的字节数。如int c &#x3D;fprintf(fp, “%s %s %d %f”, str1,str2, a, b) ;假设str1：10字节；str2：10字节；a：2字节；b：8字节；则最终c为33，因为写入时不同的数据间自动加入一个空格。\n从文件中格式化读取fscanffscanf函数的原型如下：\nint fscanf( FILE *fp,  const char* format, 地址1，地址2… );\n\n函数说明：    其中，fp是文件指针，format为格式控制字符串，地址列表为输入数据的存放地址。 \nfscanf的功能：    根据指定的格式（format参数）从文件fp中读取数据至内存（地址）。例：\n#include &lt;stdio.h&gt;  int main()&#123;    FILE *fp;       fp = fopen(&quot;a.txt&quot;,&quot;r&quot;); //需要创建a.txt文件，然后写入两个数据，空格隔开    int i=0;    double f=0;    fscanf( fp, &quot;%d%lf&quot;, &amp;i, &amp;f );    fclose(fp);    printf(&quot;%d\\n%lf\\n&quot;,i,f);    return 0;&#125;\n\n","categories":["笔记","C"],"tags":["C语言"]},{"title":"傻逼物理突击笔记","url":"/2023/02/19/%E5%82%BB%E9%80%BC%E7%89%A9%E7%90%86%E7%AA%81%E5%87%BB%E7%AC%94%E8%AE%B0/","content":"傻逼物理，🐕️都不学\n\n\n振动和波动简谐运动\n振动的能量\n振动的合成\n机械波\n波的能量\n相干波\n驻波\n多普勒效应\n光学相干光、光程差\n杨氏双缝干涉\n等倾干涉红、橙、黄、绿、青、靛、紫来表示不同颜色的可见光，可见光的范围是390 ~ 760nm，这几种颜色也反映了可见光中所包含的不同光频率和光波长，其中红光的波长最长，频率最低；紫光则波长最短，频率最高。大于760nm部分是红外光，小于390nm部分是紫外光。\n劈尖干涉\n牛顿环\n迈克尔逊干涉\n单缝衍射\n光栅衍射\n马吕斯定律\n布儒斯特定律\n气体和热力学状态方程\n速度分布函数\n热力学第一定律\n热机效率、卡诺循环\n"},{"title":"表达式求值","url":"/2022/10/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","content":"使用栈实现表达式求值\n\n\n算法\n首先运算符只有四种：加减乘除\n规则我们都知道：\n\n先乘除，后加减\n从左算到右\n先括号内，再括号外\n\n\n算法的基本思想：\n使用两个栈，一个用来储存数字，一个用来储存运算符还有括号\n对于表达式的读取可以使用 getchar，但是别忘啦对于大于 9 的数例如 10 是两个字符\n\n对于两个栈都设为空，然后给运算符栈压入第一个元素 ‘#’\n依次读入字符判断是数字还是运算符，读入运算符的时候要跟栈顶运算符进行比较。\n如果小于栈顶运算符的话就从数字栈中拿出两个数字，运算符栈中拿出一个运算符进行计算，计算结果传入数字栈。但是这个时候没有读入新的运算符，仍使用这个运算符与新的栈顶运算符比较。\n如果大于栈顶运算符的话就入栈。\n等于就是左右括号对称的情况这个时候运算符栈出栈一个即可\n\n\n\n代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#define INITCAPACITY 10 // 宏定义后面会用typedef int elemType;typedef struct Stack &#123;\telemType* array;\tint capacity;\tint top; //这里使用top来表示当前的栈顶位置，存的是栈顶元素的下标&#125;*ArrayStack;_Bool initStack(ArrayStack stack) &#123;\tstack-&gt;array = (elemType*) malloc(sizeof(elemType) * 10);\tif (stack-&gt;array == NULL) &#123;\t\treturn 0;\t&#125;\tstack-&gt;capacity = INITCAPACITY; // 宏定义\tstack-&gt;top = -1; // 栈内没有元素，所以默认为1\treturn 1;&#125;void printStack(ArrayStack stack) &#123;\tprintf(&quot;| &quot;);\tfor (int i = 0; i &lt; stack-&gt;top + 1; ++i) &#123;\t\tprintf(&quot;%d, &quot;, stack-&gt;array[i]);\t&#125;\tprintf(&quot;\\n&quot;); &#125;_Bool pushStack(ArrayStack stack, elemType element) &#123;\tif (stack-&gt;top + 1 == stack-&gt;capacity) &#123; //栈顶+1如果等于容量的话，那么说明已经塞满了\t\tint newCapacity = stack-&gt;capacity + INITCAPACITY;\t\telemType* newArray = realloc(stack-&gt;array, sizeof(elemType) * newCapacity);\t\tif (newArray == NULL) &#123;\t\t\treturn 0;\t\t&#125;\t\tstack-&gt;array = newArray;\t\tstack-&gt;capacity = newCapacity;\t&#125;\tstack-&gt;array[stack-&gt;top + 1] = element;   //直接设定栈顶元素\tstack-&gt;top++;   //栈顶top变量记得自增\treturn 1;&#125;_Bool isEmpty(ArrayStack stack) &#123; //在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛\tif (stack-&gt;top == -1) &#123; // 空为1，非空为0\t\treturn 1;\t&#125; else &#123;\t\treturn 0;\t&#125;&#125;elemType popStack(ArrayStack stack) &#123;\treturn stack-&gt;array[stack-&gt;top--]; // 返回栈顶元素并top减一&#125;elemType getPopStack(ArrayStack stack) &#123;\treturn stack-&gt;array[stack-&gt;top]; &#125;char Precede(char top, char new) &#123; // 这个函数用来判断栈顶运算符与新的运算符的优先级\tif (top == &#x27;#&#x27;) &#123;\t\tif (new == &#x27;#&#x27;) &#123; // 这个是正常的运算符关系但是对于 ‘#’ ‘#’ 的时候我直接结束了\t\t\treturn &#x27;=&#x27;;\t\t&#125; else &#123;\t\t\treturn &#x27;&lt;&#x27;;\t\t&#125;\t&#125; else if (top == &#x27;+&#x27; || top == &#x27;-&#x27;) &#123;\t\tif (new == &#x27;)&#x27; || new == &#x27;+&#x27; || new == &#x27;-&#x27; || new == &#x27;#&#x27;) &#123;\t\t\treturn &#x27;&gt;&#x27;;\t\t&#125; else &#123;\t\t\treturn &#x27;&lt;&#x27;;\t\t&#125;\t&#125; else if (top == &#x27;*&#x27; || top == &#x27;/&#x27;) &#123;\t\tif (new == &#x27;(&#x27;) &#123;\t\t\treturn &#x27;&lt;&#x27;;\t\t&#125; else &#123;\t\t\treturn &#x27;&gt;&#x27;;\t\t&#125;\t&#125; else if (top == &#x27;(&#x27;) &#123;\t\tif (new == &#x27;)&#x27;) &#123;\t\t\treturn &#x27;=&#x27;;\t\t&#125; else &#123;\t\t\treturn &#x27;&lt;&#x27;;\t\t&#125;\t&#125; else if (top == &#x27;)&#x27;) &#123;\t\treturn &#x27;&gt;&#x27;;\t&#125; else &#123;\t\treturn &#x27;\\0&#x27;;\t&#125;&#125;elemType operate(elemType a, elemType b, char operator) &#123; // 此函数用来计算数值\tif (operator == &#x27;+&#x27;) &#123;\t\treturn a + b;\t&#125; else if (operator == &#x27;-&#x27;) &#123;\t\treturn a - b;\t&#125; else if (operator == &#x27;*&#x27;) &#123;\t\treturn a * b;\t&#125; else if (operator == &#x27;/&#x27;) &#123;\t\treturn a / b;\t&#125; else &#123;\t\treturn 0;\t&#125;&#125;elemType evaluateExpressionValue() &#123;\tstruct Stack OPTR,OPND;\tinitStack(&amp;OPTR); // 运算符\tpushStack(&amp;OPTR, &#x27;#&#x27;); // 首先给optr传入一个#，当optr就剩一个#时，运算也就完成了\tinitStack(&amp;OPND); // 运算数\tint num = 0; // 这个num用来储存每次 push 给 OPND 的值\tchar c = getchar();\twhile (true) &#123;\t\tif (c == &#x27;#&#x27;) &#123; // 输入为 # 号的时候此时数字栈里面剩下两个数字，OPTR里面剩下一个#和一个运算符，此时只需要在进行一次运算即可\t\t\tchar operator = popStack(&amp;OPTR);\t\t\tint numA = popStack(&amp;OPND);\t\t\tint numB = popStack(&amp;OPND);\t\t\tint result = operate(numB, numA, operator);\t\t\tprintf(&quot;%d %c %d = %d\\n&quot;, numB, operator, numA, result);\t\t\tpushStack(&amp;OPND, result);\t\t\tbreak;\t\t&#125;else if (c - &#x27;0&#x27; &gt;= 0 &amp;&amp; c-&#x27;0&#x27; &lt;=9) &#123;\t\t\tdo &#123;\t\t\t\tnum = num * 10 + (c - &#x27;0&#x27;); // 对于大于9的数会被分为两个字符所以采用这种方式输入大于9的数字\t\t\t\tc = getchar();\t\t\t&#125; while (c - &#x27;0&#x27; &gt;= 0 &amp;&amp; c - &#x27;0&#x27; &lt;= 9);\t\t\tpushStack(&amp;OPND, num);\t\t\tnum = 0;\t\t&#125; else &#123;\t\t\tswitch (Precede(getPopStack(&amp;OPTR),c)) &#123; // 比较栈顶运算符与输入的运算符的关系\t\t\tcase &#x27;&lt;&#x27;: // 小于入栈\t\t\t\tpushStack(&amp;OPTR, c);\t\t\t\tc = getchar();\t\t\t\tbreak;\t\t\tcase &#x27;=&#x27;: // 等于时候出栈一个运算符，只有 &#x27;(&#x27; —— &#x27;)&#x27;的时候才用的到\t\t\t\tpopStack(&amp;OPTR);\t\t\t\tc = getchar();\t\t\t\tbreak;\t\t\tcase &#x27;&gt;&#x27;:\t\t\t\t&#123;\t\t\t\t\tchar operator = popStack(&amp;OPTR);\t\t\t\t\tint numA = popStack(&amp;OPND);\t\t\t\t\tint numB = popStack(&amp;OPND);\t\t\t\t\tint result = operate(numB, numA, operator);\t\t\t\t\tprintf(&quot;%d %c %d = %d\\n&quot;, numB, operator, numA, result);\t\t\t\t\tpushStack(&amp;OPND, result);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn getPopStack(&amp;OPND);&#125;int main() &#123;\tint result = evaluateExpressionValue();\tprintf(&quot;result = %d&quot;, result);\treturn 0;&#125;\n","categories":["C"],"tags":["C语言","数据结构与算法"]},{"title":"汉诺塔问题","url":"/2022/07/18/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/","content":"使用递归解决汉诺塔问题\n\n\n\n\n题目给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。\n输入格式:输入由四行：第一行是圆盘数量n(1&lt;&#x3D;n&lt;&#x3D;10);第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。\n输出格式:输出移动步骤，每行输出一步。\n输入样例:在这里给出一组输入。例如：\n2abc\n\n输出样例:在这里给出相应的输出。例如：\na-&gt;ba-&gt;cb-&gt;c\n\n题解分析过程3个柱子分别命名为起始柱、目标柱和辅助柱。\n\n1个圆盘的情况，直接移过去就行了\n2个圆盘\n\n\n\n三个圆盘\n\n\n规律：\n\n将起始柱上的 n-1 个圆盘移动到辅助柱上；\n将起始柱上遗留的 1 个圆盘移动到目标柱上；\n将辅助柱上的所有圆盘移动到目标柱上。\n\n由此，n 个圆盘的汉诺塔问题就简化成了 n-1 个圆盘的汉诺塔问题。按照同样的思路，n-1 个圆盘的汉诺塔问题还可以继续简化，直至简化为移动 3 个甚至更少圆盘的汉诺塔问题。\n代码#include&lt;stdio.h&gt;int count = 1;void hanuota(int n, char* sta, char *aux, char* tar);int main() &#123;\tint n;\tchar sta[20], aux[20], tar[20];\tscanf(&quot;%d %s %s %s&quot;, &amp;n, sta, aux, tar);\thanuota(n, sta, aux, tar);\treturn 0;&#125;void hanuota(int n, char* sta, char* aux, char* tar) &#123;\tif (n == 1) &#123;\t\t//n=1,直接移动到目标柱上 \t\tprintf(&quot;%s-&gt;%s\\n&quot;,sta, tar);\t\tcount++;\t&#125;\telse &#123;\t\thanuota(n - 1, sta, tar, aux);\t\t//将n-1移动到辅助柱上 \t\tprintf(&quot;%s-&gt;%s\\n&quot;,sta, tar);\t\tcount++;\t\thanuota(n - 1, aux, sta, tar);\t&#125;&#125;","categories":["PTA","C"],"tags":["C语言","PTA"]},{"title":"栈","url":"/2022/11/05/%E6%A0%88/","content":"栈\n\n\n栈栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：\n\n只能在一端进行插入和删除，依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，所以一般竖着看：\n\n底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一 先进后出的数据结构（FILO，First In, Last Out）\n实现栈也是非常简单的，可以基于前面的顺序表或是链表，\n\npop：出栈操作，从栈顶取出一个元素。\npush：入栈操作，向栈中压入一个新的元素。\n\n顺序栈#define INITCAPACITY 10 // 宏定义后面会用typedef int elemType;typedef struct Stack &#123;\telemType* array;\tint capacity;\tint top; //这里使用top来表示当前的栈顶位置，存的是栈顶元素的下标&#125;*ArrayStack;\n\n接着我们需要编写一个初始化方法：\n_Bool initStack(ArrayStack stack) &#123;\tstack-&gt;array = (elemType*) malloc(sizeof(elemType) * 10);\tif (stack-&gt;array == NULL) &#123;\t\treturn 0;\t&#125;\tstack-&gt;capacity = INITCAPACITY; // 宏定义\tstack-&gt;top = -1; // 栈内没有元素，所以默认为1\treturn 1;&#125;\n\nint main() &#123;\tstruct Stack stack;\tinitStack(&amp;stack);\treturn 0;&#125;\n\n入栈_Bool pushStack(ArrayStack stack, elemType element) &#123;\t// 入栈不需要index，栈是尾插法&#125;\n\n由于入栈只能在尾部插入，所以就很好写了：\n_Bool pushStack(ArrayStack stack, elemType element)&#123;    stack-&gt;array[stack-&gt;top + 1] = element;   //直接设定栈顶元素    stack-&gt;top++;   //栈顶top变量记得自增    return 1;&#125;\n\n我们来测试一下吧：\nvoid printStack(ArrayStack stack)&#123;    printf(&quot;| &quot;);    for (int i = 0; i &lt; stack-&gt;top + 1; ++i) &#123;        printf(&quot;%d, &quot;, stack-&gt;array[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    struct Stack stack;    initStack(&amp;stack);    for (int i = 0; i &lt; 3; ++i) &#123;        pushStack(&amp;stack, i*100);    &#125;    printStack(&amp;stack);&#125;\n\n测试结果也是正确的：\n\n可以看到，从栈底到栈顶一次是0、100、200，不过现在的push操作还不够完美，因为栈有可能塞满，所以要进行扩容处理：\n_Bool pushStack(ArrayStack stack, elemType element) &#123;\tif (stack-&gt;top + 1 == stack-&gt;capacity) &#123; //栈顶+1如果等于容量的话，那么说明已经塞满了\t\tint newCapacity = stack-&gt;capacity + INITCAPACITY;\t\telemType* newArray = realloc(stack-&gt;array, sizeof(elemType) * newCapacity);\t\tif (newArray == NULL) &#123;\t\t\treturn 0;\t\t&#125;\t\tstack-&gt;array = newArray;\t\tstack-&gt;capacity = newCapacity;\t&#125;\tstack-&gt;array[stack-&gt;top + 1] = element;   //直接设定栈顶元素\tstack-&gt;top++;   //栈顶top变量记得自增\treturn 1;&#125;\n\n出栈出栈操作只需要将栈顶元素取出即可：\n_Bool isEmpty(ArrayStack stack) &#123; //在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛\tif (stack-&gt;top == -1) &#123; // 空为1，非空为0\t\treturn 1;\t&#125; else &#123;\t\treturn 0;\t&#125;&#125;elemType popStack(ArrayStack stack) &#123;\treturn stack-&gt;array[stack-&gt;top--]; // 返回栈顶元素并top减一&#125;\n\n我们来测试一下吧：\nint main()&#123;    struct Stack stack;    initStack(&amp;stack);    for (int i = 0; i &lt; 3; ++i) &#123;        pushStack(&amp;stack, i*100);    &#125;    printStack(&amp;stack);    while (!isEmpty(&amp;stack)) &#123;        printf(&quot;%d &quot;, popStack(&amp;stack));   //将栈中所有元素依次出栈    &#125;&#125;\n\n可以看到，出栈顺序和入栈顺序是完全相反的：\n\n当然使用数组实现栈除了这种可以自己扩容的之外，也有固定大小的栈，当栈已满时，就无法再进行入栈操作了。\n不过有些时候，栈的利用率可能会很低，这个时候可以将一个固定长度的数组共享给两个栈来使用：\n\n数组的两头分别作为两个栈的栈底，当两个栈的栈顶指针相遇时（栈顶指针下标之差绝对值为1时），表示栈已满。 通过这种方式，我们就可以将数组占用的空间更充分地使用，这样的栈我们称为共享栈。\n链式栈使用链表会更加的方便，可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：\n\n当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：\ntypedef int elemType;typedef struct LNode &#123;\telemType element;\tstruct LNode* next;&#125;*Node;void initStack(Node list) &#123;\tlist-&gt;element = 0;\tlist-&gt;next = NULL;&#125;int main()&#123;    struct LNode stack;\tinitStack(&amp;stack);&#125;\n\n入栈和出栈入栈操作：\n\n代码如下：\n_Bool pushStack(Node list, elemType element) &#123;\tNode node = (Node) malloc(sizeof(struct LNode));\tif (node == NULL) &#123;\t\treturn 0;\t&#125;\tnode-&gt;element = element;\tnode-&gt;next = list-&gt;next;\tlist-&gt;next = node;\treturn 1;&#125;\n\n\n出栈同理，只需要将第一个元素移除即可：\n_Bool isEmpty(Node list) &#123;\tif (list-&gt;next == NULL) &#123; // 是空栈返回1\t\treturn 1;\t&#125; else &#123; // 不是返回0\t\treturn 0;\t&#125;&#125;elemType popStack(Node list) &#123;\tNode temp = list-&gt;next;\tlist-&gt;next = list-&gt;next-&gt;next;\telemType topElement = temp-&gt;element;\tfree(temp);\ttemp = NULL;\treturn topElement;&#125;\n\n打印栈void printStack(Node head)&#123;    printf(&quot;| &quot;);    head = head-&gt;next;     while (head)&#123;        printf(&quot;%d &quot;, head-&gt;element);        head = head-&gt;next;    &#125;    printf(&quot;\\n&quot;);&#125;\n\n栈练习题：\n\n若进栈序列为1，2，3，4，则不可能得到的出栈序列是？\nA.  3，2，1，4       B.  3，2，4，1C.  4，2，3，1       D.  2，3，4，1\n注意进栈并不一定会一次性全部进栈，可能会出现边进边出的情况，所以出栈的顺序可能有很多种情况，首先来看A，第一个出栈的是3，那么按照顺序，说明前面一定入栈了2、1，在出栈时4还没有入栈，然后是2、1最后是4，没有问题。接着是B，跟前面的A一样，不过这次是先出站3、2，而1留在栈中，接着4入栈，然后再让4、1出栈，也是正确的。然后是C，首先是4出栈，那么说明前三个一定都入栈了，而此时却紧接着的一定是3，而这里是2，错误。所以选择C\n\n假设有5个整数以1、2、3、4、5的顺序被压入堆栈，且出栈顺序为3、5、4、2、1，那么栈大小至少为？\nA.2B.3C.4D.5\n首先我们分析一下，第一个出栈的元素为3，那么也就是说前面的1、2都在栈内，所以大小至少为3，然后是5，那么说明此时栈内为1、2、4，算是出栈的5，那么至少需要的大小就是4了，所以选择C\n\n\n","tags":["C语言","数据结构与算法"]},{"title":"链表","url":"/2022/11/05/%E9%93%BE%E8%A1%A8/","content":"链表\n\n\n链表\n链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。\n链表分为带头结点的链表和不带头结点的链表，带头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：\n\n而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。\n创建单链表typedef int elemType;  struct ListNode &#123;      elemType element;      struct ListNode *next;  &#125;;    typedef struct ListNode *Node;\n\n创造链表的函数：\n\n首先这个函数要把创建的单链表的地址传递出来，所以用Node类型\n首先创建表头并对表头初始化\n然后创建后面的节点，可以为0\n\nNode creatList(int n) &#123;      Node headNode = (Node) malloc(sizeof(struct ListNode)); // 创建表头      headNode-&gt;next = NULL;      for (int i = 0; i &lt; n; ++i) &#123;          Node newNode = (Node) malloc(sizeof(struct ListNode));          scanf(&quot;%d&quot;, &amp;newNode-&gt;element); // 输入元素值          newNode-&gt;next = headNode-&gt;next; // 把头节点后面的节点连接到新节点          headNode-&gt;next = newNode; // 连接到头节点      &#125;      return headNode;  &#125;;\n插入与删除插入\n\n先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：\n\n\n\n接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：\n\n\n这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：\n\n按照这个思路，首先设计一下函数：\nbool insertList(Node head, elemType element, int index) &#123; // head 为表头，element 为要插入的元素， index 为要插入的位置&#125;\n\n先找到待插入位置的前驱结点：\nbool insertList(Node head, E element, int index)&#123;    if (index &lt; 1) &#123; // index &lt; 1 插入非法  \t    return false;  \t&#125;  \tfor (int i = 1; i &lt; index; ++i) &#123; // 查找要插入的节点的前驱结点  \t    head = head-&gt;next;  \t    if (head == NULL) &#123;  \t        return false;  \t    &#125;      &#125;    return true;&#125;\n\n在循环操作完成后，如果没问题那么会找到对应插入位置的前驱结点，我们只需要按照上面分析的操作来编写代码即可：\nbool insertList(Node head, elemType element, int index) &#123;      if (index &lt; 1) &#123; // index &lt; 1 插入非法          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123; // 查找要插入的节点的前驱结点          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      Node node = (Node) malloc(sizeof(struct ListNode));      if (node == NULL) &#123;          return  false;      &#125;      node-&gt;element = element;      node-&gt;next = head-&gt;next;      head-&gt;next = node;      return true;  &#125;\n\n这样，我们就编写好了链表的插入操作了，我们可以来测试一下：\nvoid printList(Node list) &#123;      Node node = list-&gt;next;      while (node != NULL) &#123;          printf(&quot;%d &quot;, node-&gt;element);          node = node-&gt;next;      &#125;      printf(&quot;\\n&quot;);  &#125;int main() &#123;      Node list = creatList(0);      for (int i = 0; i &lt; 3; ++i) &#123;          insertList(list,i*10,i+1);      &#125;      printList(list);      return 0;  &#125;\n\n成功得到结果：\n\n删除\n\n这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：\n\n那么我们就按照这个思路来编写一下程序，首先还是设计函数：\nbool deleteList(Node head, int index)&#123;    //head就是头结点，index依然是待删除的结点位序&#125;\n\n首先找到待删除结点的前驱结点：\nbool deleteList(Node head, int index)&#123;    if (index &lt; 1) &#123; // index &lt; 1 删除非法          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123; // 查找要删除的节点的前驱结点          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      return 1;&#125;\n\n最后就是按照我们上面说的删除结点了：\nbool deleteList(Node head,int index) &#123;      if (index &lt; 1) &#123; // index &lt; 1 删除非法          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123; // 查找要删除的节点的前驱结点          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      Node temp = head-&gt;next; // 拿到待删除节点，为了后面free节点      head-&gt;next = head-&gt;next-&gt;next;      free(temp);      temp = NULL;      return true;  &#125;\n\n这样就成功完成了链表的删除操作：\nint main() &#123;      Node list = creatList(0);      for (int i = 0; i &lt; 3; ++i) &#123;          insertList(list,i*10,i+1);      &#125;      printList(list);      deleteList(list,1);      printList(list);      return 0;  &#125;\n\n最后得到结果也是正确的：\n\n其他操作获取对应位置上的元素：获取对应位置的元素可以用两种方式\n\n获得元素的指针\n获得元素的值\n\n首先是第一种\nelemType * getList(Node list,int index) &#123;      if (index &lt;1) &#123;          return NULL;      &#125;      for (int i = 0; i &lt; index; ++i) &#123;          list = list-&gt;next;          if(list == NULL) &#123;              return NULL;          &#125;      &#125;      return &amp;list-&gt;element;  &#125;\n\n试验一下\nint main() &#123;      Node list = creatList(0);      for (int i = 0; i &lt; 3; ++i) &#123;          insertList(list,i*10,i+1);      &#125;      printList(list);      printf(&quot;%d&quot;,*getList(list,0));      return 0;  &#125;\n\n结果如下\n\n上面的printf(&quot;%d&quot;,*getList(list,0));中使用了[[解引用]]\n第二种\nelemType getList(Node list,int index) &#123;      if (index &lt; 1) &#123;          return -1;      &#125;      for (int i = 0; i &lt; index; ++i) &#123;          list = list-&gt;next;          if (list == NULL) &#123;              return -1;          &#125;      &#125;      return list-&gt;element;  &#125;\n\n\n查找对应元素的位置：int findList(Node list, elemType element) &#123;      list = list-&gt;next;      int i = 1;      while (list) &#123;          if (list-&gt;element == element) &#123;              return i;          &#125;          list = list-&gt;next;          i++;      &#125;      return -1; // 没找到返回-1  &#125;\n\n求链表的长度int sizeList(Node list) &#123;      int i =0;      while (list-&gt;next) &#123;          list = list-&gt;next;          i++;      &#125;      return i;  &#125;\n\n完整代码#include&lt;stdio.h&gt;  #include&lt;stdlib.h&gt;  #include&lt;stdbool.h&gt;    typedef int elemType;  struct ListNode &#123;      elemType element;      struct ListNode *next;  &#125;;    typedef struct ListNode *Node;    /**   * 该函数用来创建一个 节点数为 n 的单链表   * @param n 节点数   * @return 单链表的头节点地址   */Node creatList(int n) &#123;      Node headNode = (Node) malloc(sizeof(struct ListNode)); // 创建表头      headNode-&gt;next = NULL;      for (int i = 0; i &lt; n; ++i) &#123;          Node newNode = (Node) malloc(sizeof(struct ListNode));          scanf(&quot;%d&quot;, &amp;newNode-&gt;element); // 输入元素值          newNode-&gt;next = headNode-&gt;next; // 把头节点后面的节点连接到新节点          headNode-&gt;next = newNode; // 连接到头节点      &#125;      return headNode;  &#125;;    void printList(Node list) &#123;      Node node = list-&gt;next;      while (node != NULL) &#123;          printf(&quot;%d &quot;, node-&gt;element);          node = node-&gt;next;      &#125;      printf(&quot;\\n&quot;);  &#125;    bool insertList(Node head, elemType element, int index) &#123;      if (index &lt; 1) &#123; // index &lt; 1 插入非法          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123; // 查找要插入的节点的前驱结点          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      Node node = (Node) malloc(sizeof(struct ListNode));      if (node == NULL) &#123;          return false;      &#125;      node-&gt;element = element;      node-&gt;next = head-&gt;next;      head-&gt;next = node;      return true;  &#125;    bool deleteList(Node head, int index) &#123;      if (index &lt; 1) &#123; // index &lt; 1 删除非法          return false;      &#125;      for (int i = 1; i &lt; index; ++i) &#123; // 查找要删除的节点的前驱结点          head = head-&gt;next;          if (head == NULL) &#123;              return false;          &#125;      &#125;      Node temp = head-&gt;next; // 拿到待删除节点，为了后面free节点      head-&gt;next = head-&gt;next-&gt;next;      free(temp);      temp = NULL;      return true;  &#125;    elemType getList(Node list, int index) &#123;      if (index &lt; 1) &#123;          return -1;      &#125;      for (int i = 0; i &lt; index; ++i) &#123;          list = list-&gt;next;          if (list == NULL) &#123;              return -1;          &#125;      &#125;      return list-&gt;element;  &#125;    int findList(Node list, elemType element) &#123;      list = list-&gt;next;      int i = 1;      while (list) &#123;          if (list-&gt;element == element) &#123;              return i;          &#125;          list = list-&gt;next;          i++;      &#125;      return -1; // 没找到返回-1  &#125;    int sizeList(Node list) &#123;      int i =0;      while (list-&gt;next) &#123;          list = list-&gt;next;          i++;      &#125;      return i;  &#125;\n\n链式实现的线性表，插入、删除、获取元素操作的时间复杂度:\n**插入：因为要寻找对应位置的前驱结点，所以平均时间复杂度为$O(n)$，但是不需要做任何的移动操作，效率肯定是比顺序表要高的。\n**删除：同上，所以平均时间复杂度为$O(n)$\n**获取元素：由于必须要挨个向后寻找，才能找到对应的结点，所以时间复杂度为$O(n)$，不支持随机访问，只能顺序访问，比顺序表慢。\n\n顺序表与单链表的选择\n通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。\n而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。\n\n\n","tags":["C语言","数据结构与算法"]},{"title":"队列","url":"/2022/11/05/%E9%98%9F%E5%88%97/","content":"队列\n\n\n队列对于队列就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：\n\n秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。\n想要实现队列也是很简单的，也可以通过两种线性表来实现。\n顺序队列先使用顺序表如何实现队列，假设一开始的时候队列中有0个元素，队首和队尾一般都初始都是-1这个位置：\n\n此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素：\n\n之后都是同样的方式进行插入，队尾会一直向后移动：\n\n现在想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素：\n\n看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧？所以一般我们采用循环队列的形式，来实现重复使用一个数组（不过就没办法扩容了，大小是固定的）\n\n对于循环队列需要在移动队首队尾指针时，考虑循环的问题，也就是说如果到达了数组尽头，那么就直接从数组的前面重新开始计算，这样就相当于逻辑上都循环了，队首和队尾指针在一开始的时候都指向同一个位置，每入队一个新的元素，依然是先让队尾后移一位，在所指向位置插入元素，出队同理。\n如何判满\n由于队首指针和队尾指针重合时表示队列为空，所以我们只能舍弃一个存储单元，当队尾加一等于队首的时候，表示队列已满。\n理论结束，开始编程：\n初始化#define MAXCAPACITY 10;typedef int elemType;struct Queue &#123;\telemType* array;\tint font; // font 和 rear 表示数组下标，只不过起到了指针的作用\tint rear;\tint capacity;&#125;;typedef struct Queue* ArrayQueue;\n\n接着我们来对其进行初始化：\n_Bool initQueue(ArrayQueue queue) &#123;\tqueue-&gt;capacity = MAXCAPACITY;\tqueue-&gt;array = (elemType*) malloc(sizeof(elemType) * queue-&gt;capacity);\tif (queue-&gt;array == NULL) &#123;\t\treturn 0;\t&#125;\tqueue-&gt;font = queue-&gt;rear = 0; //默认情况下队首和队尾都指向0的位置\treturn 1;&#125;int main() &#123;\tstruct Queue queue;\tinitQueue(&amp;queue);\treturn 0;&#125;\n\n入队操作_Bool offerQueue(ArrayQueue queue, elemType element) &#123;\t// 首先判断队列是否已满，已满的话队尾指针的写一个就是队首指针\tif ((queue-&gt;rear + 1)%queue-&gt;capacity == queue-&gt;font) &#123; \t\treturn 0;\t&#125;\tqueue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity; //队尾先向前移动一位，注意取余计算才能实现循环\tqueue-&gt;array[queue-&gt;rear] = element; // 插入新元素\treturn 1;&#125;\n\n我们来测试一下：\nvoid printQueue(ArrayQueue queue) &#123;\tprintf(&quot;&lt;&lt;&lt; &quot;);\tint i = queue-&gt;font;   //遍历队列需要从队首开始\tdo &#123;\t\ti = (i + 1) % queue-&gt;capacity;   //先向后循环移动\t\tprintf(&quot;%d &quot;, queue-&gt;array[i]);  //然后打印当前位置上的元素\t&#125; while (i != queue-&gt;rear);   //当到达队尾时，结束\tprintf(&quot;&gt;&gt;&gt;\\n&quot;);&#125;int main() &#123;\tstruct Queue queue;\tinitQueue(&amp;queue);\tfor (int i = 1; i &lt; 12; i++) &#123;\t\tofferQueue(&amp;queue, i * 10);\t&#125;\tprintQueue(&amp;queue);\treturn 0;&#125;\n\n最后结果如下：\n\n出队操作_Bool isEmpty(ArrayQueue queue) &#123;\treturn queue-&gt;rear == queue-&gt;font; // 如果font = rear 则返回1，否则返回0&#125;elemType pollQueue(ArrayQueue queue) &#123;\tqueue-&gt;font = (queue-&gt;font + 1) % queue-&gt;capacity;\treturn queue-&gt;array[queue-&gt;font];&#125;\n\n我们来测试一下吧：\nint main()&#123;    struct Queue queue;    initQueue(&amp;queue);    for (int i = 0; i &lt; 5; ++i) &#123;        offerQueue(&amp;queue, i * 100);    &#125;    printQueue(&amp;queue);    while (!isEmpty(&amp;queue)) &#123;        printf(&quot;%d &quot;, pollQueue(&amp;queue));    &#125;&#125;\n\n我们来看看结果：\n\n可以看到，队列是先进先出的，以什么顺序放入队列中，那么出来的就是是什么顺序。\n同样的，队列也可以使用链表来实现，并且使用链表的话就不需、要关心容量之类的问题了，会更加灵活\n链式队列\n队列需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。\n当有新的元素入队时，只需要连接队尾就行了，同时队尾指针也要后移一位：\n\n出队时，只需要移除队首指向的下一个元素即可：\n\n实践开始：\n初始化typedef int elemType;struct LNode &#123;\telemType element;\tstruct LNode* next;&#125;;typedef struct LNode* Node;struct Queue &#123;\tNode front; // front 作为头节点\tNode rear; // rear 作为尾节点&#125;;typedef struct Queue* LinkQueue;\n\n接着是初始化，初始化的时候，需要把头结点先创建出来：\nbool initQueue(LinkQueue queue) &#123;\tNode node = (Node) malloc(sizeof(struct LNode));\tif (node == NULL) &#123;\t\treturn false;\t&#125;\tqueue-&gt;front = queue-&gt;rear = node; //一开始两个指针都是指向头结点的，表示队列为空\treturn true;&#125;int main()&#123;    struct Queue queue;\tinitQueue(&amp;queue);&#125;\n\n入队操作入队直接在后面插入新的结点就行了：\nbool offerQueue(LinkQueue queue,elemType element) &#123;\tNode node = (Node) malloc(sizeof(struct LNode));\tif (node == NULL) &#123;\t\treturn false;\t&#125;\tnode-&gt;next = NULL;\tnode-&gt;element = element; \tqueue-&gt;rear-&gt;next = node; // 首先连接新节点\tqueue-&gt;rear = node; // 尾节点后移一位\treturn true;&#125;\n\n测试一下：\nvoid printQueue(LinkQueue queue) &#123;\tprintf(&quot;&lt;&lt;&lt; &quot;);\tNode node = queue-&gt;front-&gt;next; \twhile (true) &#123;\t\tprintf(&quot;%d &quot;, node-&gt;element);\t\tif (node == queue-&gt;rear) &#123; // 每次打印完判断是否到达队尾\t\t\tbreak;\t\t&#125; else &#123;\t\t\tnode = node-&gt;next;\t\t&#125;\t&#125;\tprintf(&quot;&lt;&lt;&lt;&quot;);&#125;int main() &#123;\tstruct Queue queue;\tinitQueue(&amp;queue);\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tofferQueue(&amp;queue, i * 10);\t&#125;\tprintQueue(&amp;queue);\treturn 0;&#125;\n\n测试结果如下：\n\n\n出队操作elemType pollQueue(LinkQueue queue) &#123;\telemType element = queue-&gt;front-&gt;next-&gt;element;\tNode temp = queue-&gt;front-&gt;next; // 用来储存要删除的节点\tqueue-&gt;front-&gt;next = queue-&gt;front-&gt;next-&gt;next; // 头节点指向下一个节点\tif (temp == queue-&gt;rear) &#123; // 判断出队元素是不是最后一个\t\tqueue-&gt;rear = queue-&gt;front; // 是的话把尾指针移到头指针处\t&#125;\tfree(temp);\ttemp = NULL;\treturn element;&#125;\n\n这样，我们就编写好了：\nint main() &#123;\tstruct Queue queue;\tinitQueue(&amp;queue);\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tofferQueue(&amp;queue, i * 10);\t&#125;\twhile (!isEmpty(&amp;queue)) &#123;\t\tprintf(&quot;%d &quot;, pollQueue(&amp;queue));\t&#125;\treturn 0;&#125;\n\n测试结果如下：\n\n\n","tags":["C语言","数据结构与算法"]},{"title":"顺序表","url":"/2022/09/25/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","content":" 数据结构 -&gt; 线性表 -&gt; 顺序表\n\n\n顺序表顺序表就是数组的一个变形，比数组的功能更加丰富\n\n先定义一个新的结构体类型，将一些需要用到的数据保存在一起，以int类型的线性表为例：\ntypedef int elemType;  //这里我们的元素类型就用int为例吧，先起个别名struct List &#123;    elemType array[10];   //实现顺序表的底层数组    int capacity;   //表示底层数组的容量&#125;;\n\n起个别名的目的是为了程序简洁以及后面程序的改动\ntypedef struct List * ArrayList; \n\n为结构体指针起别名，程序更加简洁\n初始化链表void initList(ArrayList list)&#123;    list-&gt;capacity = 10;   //直接将数组的容量设定为10即可&#125;\n\n上述初始化无法达到动态内存的目的\n所以应该使用动态内存分配的方式来初始化链表\nstruct List &#123;    elemType * array;   //指向顺序表的底层数组    int capacity;   //数组的容量&#125;;\n\n接着我们修改一下初始化函数：\nvoid initList(ArrayList list)&#123;  //这里就默认所有的顺序表初始大小都为10吧，随意    list-&gt;array = malloc(sizeof(elemType) * 10);   //使用malloc函数申请10个int大小的内存空间，作为底层数组使用    list-&gt;capacity = 10;    //容量同样设定为10&#125;\n\n表里面，默认情况下是没有任何元素的，还需要一个变量来表示当前表中的元素数量：size\nstruct List &#123;    elemType * array;   //指向顺序表的底层数组    int capacity;   //数组的容量    int size;   //表中的元素数量&#125;;typedef struct List * ArrayList;void initList(ArrayList list)&#123;  //这里就默认所有的顺序表初始大小都为10吧，随意    list-&gt;array = malloc(sizeof(elemType) * 10);   //使用malloc函数申请10个elemType大小的内存空间，作为底层数组使用    list-&gt;capacity = 10;    //容量同样设定为10    list-&gt;size = 0;   //元素数量默认为0&#125;\n还有一种情况，动态内存申请时可能会申请失败\nBool initList(ArrayList list)&#123;    list-&gt;array = malloc(sizeof(elemType) * 10);    if(list-&gt;array == NULL) return false;  //需要判断如果申请的结果为NULL的话表示内存空间申请失败    list-&gt;capacity = 10;    list-&gt;size = 0;    return true;   //正常情况下返回true也就是1&#125;\n\n这样，一个比较简单的顺序表就定义好，我们可以通过initList函数对其进行初始化：\nint main() &#123;    struct List list;   //创建新的结构体变量    if(initList(&amp;list))&#123;   //对其进行初始化，如果失败就直接结束      \t...    &#125; else&#123;        printf(&quot;顺序表初始化失败，无法启动程序！&quot;);    &#125;&#125;\n插入和删除链表插入\n\n设计函数\nvoid insertList(ArrayList list, elemType element, int index)&#123;    \t//list就是待操作的表，element就是需要插入的元素，index就是插入的位置（注意顺序表的index是按位序计算的，从1开始，一般都是第index个元素）&#125;\n\n编写代码：\nvoid insertList(ArrayList list, elemType element, int index)&#123;    for (int i = list-&gt;size; i &gt; index - 1; i--)  //先使用for循环将待插入位置后续的元素全部丢到后一位        list-&gt;array[i] = list-&gt;array[i - 1];    list-&gt;array[index - 1] = element;    //挪完之后，位置就腾出来了，直接设定即可    list-&gt;size++;   //别忘了插入之后相当于多了一个元素，记得size + 1&#125;\n\n测试一下\nvoid printList(ArrayList list)&#123;   //编写一个函数用于打印表当前的数据    for (int i = 0; i &lt; list-&gt;size; ++i)   //表里面每个元素都拿出来打印一次        printf(&quot;%d &quot;, list-&gt;array[i]);    printf(&quot;\\n&quot;);&#125;\n\nint main() &#123;    struct List list;    if(initList(&amp;list))&#123;        insertList(&amp;list, 666, 1);  //每次插入操作后都打印一下表，看看当前的情况         printList(&amp;list);        insertList(&amp;list, 777, 1);        printList(&amp;list);        insertList(&amp;list, 888, 2);        printList(&amp;list);    &#125; else&#123;        printf(&quot;顺序表初始化失败，无法启动程序！&quot;);    &#125;&#125;\n\n运行结果如下：\n\n虽然这样看起来没什么问题了，但是如果我们在非法的位置插入元素会出现问题：\ninsertList(&amp;list, 666, -1);   //第一个位置就是0，怎么可能插入到-1这个位置呢，这样肯定是不正确的，所以我们需要进行判断printList(&amp;list);\n\n我们需要检查一下插入的位置是否合法：\n\n转换成位序，也就是[1, size + 1]这个闭区间，所以我们在一开始的时候进行判断：\nBool insertList(ArrayList list, elemType element, int index)&#123;    if(index &lt; 1 || index &gt; list-&gt;size + 1) return false;   //如果在非法位置插入，返回0表示插入操作执行失败    for (int i = list-&gt;size; i &gt; index - 1; i--)        list-&gt;array[i] = list-&gt;array[i - 1];    list-&gt;array[index - 1] = element;    list-&gt;size++;    return true;   //正常情况返回1&#125;\n\n我们可以再来测试一下：\nif(insertList(&amp;list, 666, -1))&#123;    printList(&amp;list);&#125; else&#123;    printf(&quot;插入失败！&quot;);&#125;\n\n\n不过还是没有考虑到一个情况，那么就是如果我们的表已经装满了，也就是说size已经达到申请的内存空间最大的大小了，那么此时我们就需要考虑进行扩容了，否则就没办法插入新的元素了：\nBool insertList(ArrayList list, elemType element, int index)&#123;    if(index &lt; 1 || index &gt; list-&gt;size + 1) return false;    if(list-&gt;size == list-&gt;capacity) &#123;   //如果size已经到达最大的容量了，肯定是插不进了，那么此时就需要扩容了        int newCapacity = list-&gt;capacity + (list-&gt;capacity &gt;&gt; 1);   //我们先计算一下新的容量大小，这里我取1.5倍原长度，当然你们也可以想扩多少扩多少        elemType * newArray = realloc(list-&gt;array, sizeof(elemType) * newCapacity);  //这里我们使用新的函数realloc重新申请更大的内存空间        if(newArray == NULL) return 0;   //如果申请失败，那么就确实没办法插入了，只能返回0表示插入失败了        list-&gt;array = newArray;        list-&gt;capacity = newCapacity;    &#125;    for (int i = list-&gt;size; i &gt; index - 1; i--)        list-&gt;array[i] = list-&gt;array[i - 1];    list-&gt;array[index - 1] = element;    list-&gt;size++;    return true;&#125;\n\nrealloc函数可以做到控制动态内存开辟的大小，重新申请的内存空间大小就是我们指定的新的大小，并且原有的数据也会放到新申请的空间中，所以非常方便。当然如果因为内存不足之类的原因导致内存空间申请失败，那么会返回NULL，所以别忘了进行判断。\n这样，我们的插入操作就编写完善了，我们可以来测试一下：\nint main() &#123;    struct List list;    if(initList(&amp;list))&#123;        for (int i = 0; i &lt; 30; ++i)            insertList(&amp;list, i, i);        printList(&amp;list);    &#125; else&#123;        printf(&quot;顺序表初始化失败，无法启动程序！&quot;);    &#125;&#125;\n\n成功得到结果：\n\n这样，我们就完成了顺序表的插入操作，接着我们来编写一下删除操作，其实删除操作也比较类似，也需要对元素进行批量移动，但是我们不需要考虑扩容问题，我们先设计好函数：\nvoid deleteList(ArrayList list, int index)&#123;    \t//list就是待操作的表，index是要删除的元素位序&#125;\n\n按照我们上面插入的思路，我们反过来想一想然后实现删除呢？首先是删除的范围：\n\n换算成位序就是[1, size]这个闭区间内容，所以我们先来限定一下合法范围：\nBool deleteList(ArrayList list, int index)&#123;    if(index &lt; 1 || index &gt; list-&gt;size) return false;    return true;  //正常情况返回1&#125;\n\n接着就是删除元素之后，我们还需要做什么呢？我们应该将删除的这个元素后面的全部元素前移一位：\n\n我们按照这个思路，来编写一下删除操作：\nBool deleteList(ArrayList list, int index)&#123;    if(index &lt; 1 || index &gt; list-&gt;size) return false;    for (int i = index - 1; i &lt; list-&gt;size - 1; ++i)        list-&gt;array[i] = list-&gt;array[i + 1];   //实际上只需要依次把后面的元素覆盖到前一个即可    list-&gt;size--;   //最后别忘了size - 1    return true;&#125;\n\n删除相比插入要简单一些，我们来测试一下吧：\nfor (int i = 0; i &lt; 10; ++i)  //先插10个    insertList(&amp;list, i, i);deleteList(&amp;list, 5);   //这里删除5号元素printList(&amp;list);\n\n成功得到结果：\n\nOK，那么插入和删除操作我们就成功完成了，还有一些比较简单的功能，我们这里也来依次实现一下，首先是获取长度：\nint sizeList(ArrayList list)&#123;    return list-&gt;size;   //直接返回size就完事&#125;\n\n接着是按位置获取元素和查找指定元素的位置：\nelemType * getList(ArrayList list, int index)&#123;    if(index &lt; 1 || index &gt; list-&gt;size) return NULL;   //如果超出范围就返回NULL    return &amp;list-&gt;array[index - 1];&#125;\n\nint findList(ArrayList list, elemType element)&#123;    for (int i = 0; i &lt; list-&gt;size; ++i) &#123;   //一直遍历，如果找到那就返回位序        if(list-&gt;array[i] == element) return i + 1;    &#125;    return -1;  //如果遍历完了都没找到，那么就返回-1&#125;\n","categories":["笔记","C"],"tags":["C语言"]}]